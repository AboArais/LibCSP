\chapter{Introduction}
\label{chapter:introduction}
Todays notion of a \textit{computer} is often implicitly associated with general purpose computers such as desktops, laptops or even tablets used for information processing. However, computers, also extend to other domains such as controlling or monitoring physical hardware. Such tasks, where applications participate in a larger system and interact directly with the real world are typically referred to as \textit{embedded systems}. Examples of such systems are braking system in cars and software for washing machines. An indication of the importance of embedded systems can be seen in the production of microprocessors. An estimated 99\% of the worlds production is for use in embedded systems\cite{alan2001real}. Different applications of embedded systems can also induce more strict demands for reliability and responsiveness of the software. Consider an automatic door that opens upon proximity of a person. When approaching this door, it must begin to open in \textit{reasonable} time such that the person approaching can just keep on walking through the door in the same pace without slowing down or even stopping for it to fully open. This type of system in which the system must take timing constraints into consideration are referred to as \textit{real-time systems}. While several definitions exists, we here provide the following definition:

\begin{quotation}
``Any information processing activity or system which has to respond to externally generated input stimuli within a finite and specified period.''~\cite{alan2001real}
\end{quotation}

Depending on the type of embedded system and the application area, timing delays leading to failures may also result in more serious consequences. Applications where a failure to respond within timing constraints (or an incorrect response is produced) results in loss of life, are referred to as \textit{safety-critical systems}\cite{SCJSpec}. As a result of the possible consequences, safety-critical systems must go through a strict and rigorous certification and validation process before being put into use. One example of such certification processes is the \textit{Software Considerations in Airborne Systems and Equipments Certification} (DO-178B)\cite{DO178B}, that the \textit{Federal Aviation Administration} (FAA) requires safety-critical software to be certified against within the United States (and equivalent is found in Europe). As an example, with the highest level of certification (level A) under DO-178B, the compiled object code must be analysed in depth in order to verify correct behaviour and to find and inspect all compiler made optimisations\cite{DO178B-Example}.

Currently developing safety-critical systems is done using languages in which there are little nondeterminism, such as the C or Ada (in the Ravenscar profile) programming languages, due to the predictable semantics as a result of, amongst other things, the manual memory management. This, however, also presents some challenges as with the great control that e.g. C provides, greater responsibility is imposed on the programmer and requires increased work effort. One must deal with this manual memory management correctly such as ensuring the absence of buffer overflows and manually deallocating objects.

Attempts have been made to enable the development of real-time and safety-critical systems using Java. Motivations for this are primarily grounded in its attractiveness due to its type-safety and widespread familiarity that supposedly leads to increased programmer productivity\cite{henties:2009-20, Nilsen96issuesin}.
The \textit{Safety-Critical Java} (SCJ) specification under \textit{JSR-302}\cite{JSR, SCJSpec}, based on the existing \textit{Real-Time Specification for Java} (RTSJ), is an attempt to leverage the benefits of Java for safety-critical system development. The primary goal of SCJ is to enable the development of applications that can be certified against rigorous certification standards such as DO-178B level A. As SCJ is not yet completed, few implementations and use cases exist which are required in order to thoroughly evaluate the specification and validate its design.
In this study we wish to examine the development of real-time applications using SCJ, as well as contribute and complement the further development of SCJ from its current state. Java for real-time embedded and safety-critical systems is an important research area, and in the following sections we examine the current state of SCJ and identify some of the currently hot topics in which this project may contribute.

\section{The Current State of SCJ}
In this Section we will briefly examine the current state of \textit{Safety-Critical Java} (SCJ) and topics that are open for work in order to find a suitable area to contribute in bringing Java into safety-critical systems. Note that this will not provide a thorough introduction to SCJ but rather serves to describe its presence and relation to other Java versions.

\subsection{Brief History} % (fold)
\label{sub:brief_history_of_java_for_safety_critical_systems}
For several years Java has been widely applied in the industry as the programming language and platform for many software development projects. The \textit{standard edition} (SE) of Java, however, is not directly applicable in the area of real-time systems (and in particular safety-critical systems). The \textit{Real-Time Specification for Java} (RTSJ) under \textit{JSR-001}\cite{alan2001real, henties:2009-20} was a significant breakthrough that, amongst other things, specified constraints for Java in terms of thread scheduling and memory management that are necessary in order to meet the requirements for developing real-time systems. A number of virtual machines for RTSJ have been implemented and interesting use cases have been developed. Notable examples are experimenting with RTSJ for an unmanned aerial vehicle (UAV) at Boeing\cite{Armbruster:2007:RJV:1324969.1324974} and experimenting with the programming model in RTSJ for space missions, done in collaboration with NASA\cite{DBLP:conf/isorc/DvorakBCCCGIMMR04}. However, despite such prominent actors having invested time and effort into RTSJ, it has been the subject of much debate. Primarily, the application of RTSJ e.g. for safety-critical applications, has been questioned due to its comprehensive size and complexity. As a result, attempts to simplify RTSJ have been made such as the Ravenscar Java profile\cite{Kwon:2002:RHI:583810.583825}, Predictable Java\cite{Bogholm:2009:PJP:1620405.1620427} and SCJ in which the latter has become the most prominent one.

Safety-Critical Java was initiated in 2006 under JSR-302 as a subset of RTSJ with additional classes\cite{Schoeberl:2012:SCJonJava}. Led by the ``The Open Group'' with involvement from representatives from companies such as Boeing, Oracle and IBM, SCJ is currently being finalised, but requires some kind of validation in order to approve its application for safety-critical software. As the specification was initiated in 2006, many things have happened in the area since, and the surroundings (such as certification requirements) have changed in some areas which may allow easing some of the restrictions under which SCJ applications are developed. In the following we will look at some of these interesting topics that are open for work in relation to SCJ.

% subsection brief_history_of_java_for_safety_critical_systems (end)

% Additionally, one of key people in the community, Martin Schoeberl, describe these as necessary for proper evaluation and further development of the specification\cite{Schoeberl:2012:SCJonJava}

\subsection{Hot Topics in the Community} % (fold)
\label{sub:interestingresearch}
An explicitly stated need in the community is that of SCJ implementations and use cases\cite{Schoeberl:2012:SCJonJava} in order to evaluate and refine the specification.
At the time of writing, a limited open-source prototype implementation supporting non-complex SCJ applications is available under the name, oSCJ\cite{oSCJ}. However, this can be considered to be either in a hibernation state or shelved due to inactivity. Another prototype implementation of SCJ, that offers a larger subset of the specification, is available on the \textit{Java Optimized Processor}~(JOP), a hardware implementation of the JVM\cite{Schoeberl:2012:SCJonJava}. Besides supporting the specification development by providing implementations of the specification, practical use cases of SCJ applications are needed. In this regard, two public available use cases have been developed, namely a desktop RepRap 3D printer\cite{Schoeberl:2012:RepRap} and a cardiac pacemaker\cite{Singh:2012:CPC:2388936.2388948}\footnote{This use case can, however, be discussed if it can be classified as an SCJ application as they deviate from the specification.}. These use cases have been presented at the \textit{Java Technology for Real-Time and Embedded Systems}~(JTRES) workshop. The call for implementations and use cases is both present in many research papers covering the area, but also something that has been pointed out several times by our supervisor who has been attending JTRES several times, reinforcing the need.

Another interesting and much debated area of research is in relation to the memory model. SCJ inherits from RTSJ, a special memory model in order to compensate the lack of automatic garbage collection. Furthermore using garbage collectors in real-time systems has not been considered a viable option until now, due to timing and analysis difficulties. Recently, however, there has been a breakthrough towards garbage collection in real-time and safety-critical applications, as \textit{ESA} has opened up for allowing such techniques(cite to doc). Incorporating a feasible garbage collector is, however, not a straightforward task as it entails overcoming several challenges such as specifying an acceptable release frequency, avoiding memory fragmentation and minimising interference in terms of blocking. In relation to release frequencies a formula for calculating the highest possible release time exists, however with requirements\footnote{The application must only consist of hard read-time periodic tasks} posed on the SCJ application. It requires the maximum memory allocation consumption of all application threads to be known in advance\cite{Schoeberl:2007:GCS:1288940.1288953}. Naturally this also raises a need for tools that are able to compute these memory consumption values by e.g. analysing the application source code. The memory management model is in general an interesting area with many open areas in which it is possible to contribute.

\section{GomSpace and the Cubesat Space Protocol} % (fold)
\label{sec:gomspace_and_the_cubesat_space_protocol}
Having just described some of the current hot topics, we see great opportunity in working with a use case that can benefit the further development of SCJ and its specification.

\textit{GomSpace ApS} is a university spin-off company that specialises in space mission solutions with emphasis on Cubesat and nano-satellite platforms\cite{GomSpace}. One of the key software elements in their repertoire is the \textit{Cubesat Space Protocol}~(CSP). The CSP library is a small network-layer delivery protocol directly for Cubesats, that can allow distributed systems (such as the case of a space mission) to communicate using a simple API that closely resembles that of Berkeley sockets. Currently the library is implemented in C with much focus on small footprint and high performance. GomSpace, however, is interested in pushing for other possibilities in developing such software solutions in their area, which is inherently mission-critical. This includes interest in the possible use of Java technology due to the previously stated benefits (see Section \ref{chapter:introduction}) that may be harvested, and therefore for this study we have been able to work with the GomSpace company to provide a use case of real safety-critical dimensions for SCJ.

% section gomspace_and_the_cubesat_space_protocol (end)

\section{Problem Statement} % (fold)
\label{sec:problem_statement}
We have described the apparent lack of use cases and real applications of SCJ and briefly introduced the Cubesat Space Protocol. Because this is a central element in their space solutions, we choose to examine this protocol in depth and see how this can be implemented in SCJ. We would like to emphasise the opportunities that arise with the CSP in SCJ. First, the inherent ability to provide the use case for the community, which opens up for the opportunity to continue the work later with more applications by having the ability to communicate with existing modules in a space mission from SCJ applications. Choosing to implement CSP in SCJ may therefore also provide a ground for many other contributions in the community.

Based on this, we state the following problem statement for this project:
\begin{quotation}
	\textit{Can the network-layer delivery protocol, Cubesat Space Protocol, be designed and implemented using Safety-Critical Java, such that it can be used for applications that communicates with peripheral modules?}
\end{quotation}
In addition to the statement of the problem we outline the following subsidiary goals and questions:
%An additional reason for working with this topic is in relation to our personal backgrounds. We have great interest in software development and believe that with our background in Software Engineering, which includes much experience working with Java and similar platforms, we are able to provide some reflection on applying SCJ from a developer perspective. As previously stated many of the motivations behind bringing Java technology to safety-critical systems is that of programmer productivity, as well as letting many of the Java developers out there develop safety-critical systems. Therefore as a part of the problem, we wish to examine this and in the end reflect upon SCJ from our point of view as a part of the use case. We can outline these additional questions:
\begin{itemize}
	\item When working with this use case, to what degree is it possible to apply existing Java experience to the development of safety-critical systems using SCJ?
	\item Are there elements in the specification that could be changed for the better?
	\item As CSP is effectively a library, which considerations must one take into account when developing libraries for SCJ in contrast to standard edition Java? Furthermore how can such libraries be made to ease the use for developers with prior Java experience?
	\item As a result of the use case, are there any topics or encountered issues that are worth examining in depth for future work?
\end{itemize}

Furthermore, in order to be able to reflect upon these questions and provide a conclusion for the problem statement, we have the goal of building an SCJ application on top of the implemented CSP protocol. This serves the goal of documenting the development of a real-time safety-critical application using the CSP implementation, and how a Java developer would see this task.

% subsection method (end)

% subsection delimitation (end)

% subsection grounds_and_goals (end)

% section problem_statement (end)
