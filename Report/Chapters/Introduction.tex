\chapter{Introduction}
\label{chapter:introduction}
Todays notion of a \textit{computer} is often implicitly associated with general purpose computers such as desktops, laptops or even tablets used for information processing. However, computers, also extends to other areas of domains such as controlling or monitoring physical hardware. Such tasks, where computers interact directly with the real world are typically referred to as \textit{embedded systems}. Examples of such systems are braking system in cars and software for washing machines. An indication of the importance of embedded systems can be seen in the production of microprocessors. An estimated 99\% of the worlds production is for use in embedded systems\cite{alan2001real}. Different applications of embedded systems also makes more strict demands for reliability of the software. Consider an embedded system for air traffic control. Timing delays leading to faults in such a system may have more serious consequences in contrast to a general purpose computer where only the user experience would suffer. This type of system in which the system must take timing constraints into consideration are referred to as \textit{real-time systems}. While several definitions exists, we here provide the following definition:

\begin{quotation}
"Any information processing activity or system which has to respond to externally generated input stimuli within a finite and specified period." \cite{alan2001real}
\end{quotation}

Depending on the type of embedded system, failures may also result in more fatal consequences. Applications where a failure to respond within timing constraints (or an incorrect response is produced) results in a significant loss, or even life, are referred to as \textit{safety-critical systems}(cite SCJ spec). As a result of the possible consequences, safety-critical systems must go through a strict and rigorous certification and validation process before being put into use. One example of such certification processes is the \textit{Software Considerations in Airborne Systems and Equipments Certification} (DO-178B)\cite{DO178B}, that the \textit{Federal Aviation Administration} requires safety-critical software to be certified against within the United States (and equivalent is found in Europe). As an example, with the highest level of certification (level A) under DO-178B, the compiled object code must be analysed in depth in order to verify correct behaviour and to find and inspect all compiler made optimisations\cite{DO178B-Example}.


Currently developing safety-critical systems is done using languages in which there is little nondeterminism, such as the C or Ada (in the Ravenscar profile) programming languages, due to their ability to write predictable software as a result of, amongst other things, the manual memory management. This, however, also presents some challenges as with the great control that e.g. C provides, a greater responsbility in the development is put upon the programmer. One must deal with this manual memory management correctly, and ensure no buffer overflows, and manually deallocating allocated memory.
Recently, attempts have been made to bring Java into the area of real-time and safety-critical systems. Motivations for this are primarily grounded in its attractiveness due to its type-safety, programmer productivity and availability of programmers. In other words, developing a system in a high-level language reduces the risk of making errors in the process, and this can be considered an extremely feasible goal to achieve for safety-critical systems development.
The Safety-Critical Java (SCJ) specification under \textit{JSR-302}\cite{JSR}(cite til spec), based on the existing \textit{Real-Time Specification for Java} (RTSJ), is an attempt to leverage the many benefits of Java for safety-critical systems development, which require behaviour and performance that is predictable as well as being reliable(cite spec). The primary goal of SCJ is to enable the development of applications that can be certified against rigorous certification processes such as DO-178B level A. As the specification is not yet completed, and still a draft, few implementations and use cases exists which are required in order to thoroughly evaluate the specification and validate its design.
In this study we wish to examine developing real-time applications using Safety-Critical Java, as well as contribute and complement the further development of Safety-Critical Java, from its current state. Java for real-time embedded and safety-critical systems is an important research area, and in the following Sections we examine the current state of Safety-Critical Java and open areas in the research area, in which this project may contribute.

\section{The Current State of SCJ}
In this Section we will briefly examine the current state of Safety-Critical Java and areas that are open for work in order to find a suitable area to contribute in bringing Java to safety-critical systems. Note that this will not provide a thorough introduction to SCJ but rather serves to describe why it is here.

\subsection{Brief History} % (fold)
\label{sub:brief_history_of_java_for_safety_critical_systems}
For several years Java has been widely applied in the industry as the programming language and platform for many software development projects. The standard edition of Java, however, is not directly applicable in the area of real-time systems (and in particular safety-critical systems). The Real-Time Specification for Java (RTSJ) under JSR-001\cite{alan2001real}\cite{henties:2009-20} was a significant breakthrough that specified constraints of Java in terms of thread scheduling and memory management amongst other things, that are necessary in order to meet the requirements of developing real-time systems. A number of virtual machines for RTSJ have been implemented, and interesting use cases have been developed. Notable examples are experimenting with RTSJ for an unmanned aerial vehicle (UAV) at Boeing\cite{Armbruster:2007:RJV:1324969.1324974} and experimenting with the programming model in RTSJ for space missions, done in collaboration with NASA\cite{DBLP:conf/isorc/DvorakBCCCGIMMR04}. However, despite such prominent actors having invested time and effort into RTSJ, it has been the subject of much debate. Primarily, the application of RTSJ for e.g. safety-critical applications has been questioned due to its size and complexity. As a result, attempts to simplify RTSJ have been made, such as the Ravenscar Java profile and Safety-Critical Java in which the latter has become the most prominent one.

Safety-Critical Java was initiated in 2006 as JSR-302 led by "The Open Group", and the specification has been under development since then, with involvement from representatives from companies such as Boeing, Oracle and IBM. Having just passed its 6th birthday, the specification is nearing its completion and is currently being finalised. This does not, however, mean that one can simply begin to develop SCJ applications, as there are still future work to be done. First, the specification requires some kind of validation in order to approve its application for safety-critical software. Second, as the specification originates back from 2006, many things have happened in the area since, and the surroundings (such as certification requirements) have changed in some areas which may allow easing some of the restrictions under which SCJ applications are developed. In the following we will look at some of these interesting topics that are open for work in relation to SCJ.

% subsection brief_history_of_java_for_safety_critical_systems (end)


\subsection{Hot Topics in the Community} % (fold)
\label{sub:interestingresearch}
As the SCJ specification is still in public draft and thereby under constant evaluation both from the outside world and within, the expert group desperately need independent implementations of it in order to refine it \cite{Schoeberl:2012:SCJonJava}. Currently at the time of writing, a limited open-source prototype implementation supporting non-complex SCJ applications is available under the name, oSCJ \cite{oSCJ}. As the implementation is extremely limited and because there is little to no activity in the code repository, it can be considered as being either in a hibernation state or shelved. Fortunately, another prototype implementation of SCJ that offers a larger subset of the specification to run on the Java Optimized Processor, a hardware implementation of the JVM, is also available \cite{Schoeberl:2012:SCJonJava}. This implementation supports the creation and execution of more complex SCJ applications. Besides supporting the specification development by providing implementations of the specification, the expert group also needs more practical use cases of SCJ applications. In this regard, only two public available use cases have been developed, namely a desktop RepRap 3D printer \cite{Schoeberl:2012:RepRap} and a cardiac pacemaker cite(The Cardiac Pacemaker Case Study and its implementation in Safety-Critical Java and Ravenscar Ada). The call for implementations and use cases is both present in many research papers covering the area, but also something that has been pointed out several times by our supervisor who has been attending the \textit{Java Technology for Real-Time and Embedded Systems} (JTRES) workshop several times, reinforcing the need.

Another interesting and highly debated area of research is in relation to the memory model. SCJ uses a rather special memory model in order to compensate the lack of automatic garbage collection. Furthermore using garbage collectors in real-time systems has not been considered a viable options up until now, due to timing and analysis difficulties due to unpredictable behaviour. Recently, however, there has been a breakthrough towards garbage collection in real-time and safety-critical applications, as ESA has opened up for allowing such techniques(cite til dok). One can therefore maybe say that the memory model in SCJ is becoming outdated, as it was designed under different circumstances. Incorporating a feasible garbage collector is, however, not a straightforward task as it entails to overcome several challenges such as specifying an acceptable release frequency, avoiding memory fragmentation and minimizing interference in terms of blocking. In relation to release frequencies a formula for calculating the highest possible release time, however with requirements posed on the SCJ application, exists but requires the maximum memory allocation consumption of all application threads to be known in advance \cite{Schoeberl:2007:GCS:1288940.1288953}. Naturally this also raises a need for tools that are able to compute these memory consumption values by analysing the application source code.

\section{GomSpace and the Cubesat Space Protocol} % (fold)
\label{sec:gomspace_and_the_cubesat_space_protocol}
Having just described some of the interesting topics, a great opportunity lies in a this study, to work with a use case that can benefit the further development of SCJ and its specification.

GomSpace ApS is a university spinoff company currently residing in the NOVI Science Park, that is placed in the same area as the Aalborg University campus. GomSpace specialises in space mission solutions, with emphasis on Cubesat and nano-satellite platforms\cite{GomSpace}. The expertise of GomSpace in small satellite technology covers both electronic as well as software engineering. The entrepreneurs behind GomSpace has also been part of some of the Cubesat projects during their time of study at Aalborg University, that was successfully launched into space. In fact, they were part of the AAU-Cubesat which was the first Cubesat in Europe that was launched into space.

One of the key software elements in their repertoire, is the Cubesat Space Protocol (CSP). Started during their time as students, the CSP library is a small network-layer delivery protocol directly for Cubesats, that can allow distributed systems (such as the case of a space mission) to communicate using a simple API that closely resembles that of Berkeley sockets. Currently the library is implemented in C with much focus on low footprint and performance. GomSpace, however, is interested in pushing for other possibilities in developing such software solutions in their area, which is inherently safety-critical. This includes interest in the possible use of Java technology due to the previously stated benefits that may be harvested, and therefore for this study we have been able to work the GomSpace company to provide a use case of real safety-critical dimensions for SCJ.

% section gomspace_and_the_cubesat_space_protocol (end)

\section{Problem Statement} % (fold)
\label{sec:problem_statement}
Having examined current state and open topics in the community surrounding use of Java technology for safety-critical systems, we now turn to the clarification of a problem that we will base this study upon. In Section \ref{sub:interestingresearch} we listed some of the topics that we have seen, where putting in some work effort, would be a contribution to some degree. One of these were the inherent apparent lack of use cases and real applications of SCJ that one of the key people in the community describe as necessary for proper evaluation and further development of the specification. Combined with the opportunity of working with GomSpace that also has interest in this, and has real applications that are safety-critical, we consider a use case study of applying the SCJ in use a great opportunity.

We briefly mentioned the Cubesat Space Protocol. Because this is a central element in their space solutions, we choose to examine this protocol in depth and see how this can be transferred to SCJ. We would like to emphasise the opportunities that arise with the CSP in SCJ. First, the inherent ability to provide the use case for the community, but there is also the opportunity to continue the work later with more applications by having the ability to communicate with existing modules in a space mission from SCJ applications. Choosing to implement CSP in SCJ may therefore also provide a ground for many other contributions in the community.

We have therefore reached the ability to state the following problem statement for this study:
\begin{quotation}
	\textit{Can the network-layer delivery protocol, Cubesat Space Protocol, be designed and implemented using Safety-Critical Java, such that it can be applied for applications that relies on communicating with peripheral modules in a safety-critical environment?}
\end{quotation}
In addition to the statement of the problem, we wish to outline some of the key goals, that is, what we wish to examine as a part of this study.

An additional reason for working with this topic is our personal backgrounds. We have great interest in software development, and we believe that with our background in Software Engineering, which includes much experience working with Java and similar platforms, we are able to provide some reflection on applying SCJ as developers would see it. As previously stated many of the motivations behind bringing Java technology to safety-critical systems is that of programmer productivity, as well as letting many of the Java developers out there develop safety-critical systems. Therefore as a part of the problem, we wish to examine this and in the end reflect upon the SCJ from our point of views as a part of the use case. We can outline these additional questions as following:
\begin{itemize}
	\item When working with this use case - to what degree is it possible to apply existing Java experience to the development of safety-critical systems using SCJ?
	\item Are there elements in the specification that could be changed for the better?
	\item As CSP is effectively a library, which considerations must one take into account when developing libraries for SCJ in contrast to standard edition Java? And how can such libraries be made to ease the use for developers with prior Java experience?
	\item Ass a result of the use case, are there any topics or encountered issues that is worth examining in depth for future work?
\end{itemize}

Furthermore, in order to be able to reflect upon these questions and provide a conclusion for the statement of the problem, we have the goal of building an SCJ application on top of the implemented CSP protocol. This serves the goal of both 
validating the implementation of CSP, as well as being able to illustrate the development of a real-time safety-critical application using the CSP implementation, and how a Java developer would see this task.

% subsection method (end)

% subsection delimitation (end)

% subsection grounds_and_goals (end)

% section problem_statement (end)
