\chapter{Introduction}
\label{chapter:introduction}
Todays notion of a \textit{computer} is often implicitly associated with general purpose computers such as desktops, laptops or even tablets used for information processing. However, computers, also extends to other areas of domains such as controlling or monitoring physical hardware. Such tasks, where applications participate in a larger system and interact directly with the real world are typically referred to as \textit{embedded systems}. Examples of such systems are braking system in cars and software for washing machines. An indication of the importance of embedded systems can be seen in the production of microprocessors. An estimated 99\% of the worlds production is for use in embedded systems\cite{alan2001real}. Different applications of embedded systems can also induce more strict demands for reliability and responsiveness of the software. Consider an automatic door that opens upon proximity. When approaching this door, it must begin to open in \textit{reasonable} time such that the person approaching can just keep on walking through the door in the same pace without slowing down or even stopping for it to fully open. This type of system in which the system must take timing constraints into consideration are referred to as \textit{real-time systems}. While several definitions exists, we here provide the following definition:
%Consider an embedded system for air traffic control.Timing delays leading to faults in such a system may have more serious consequences in contrast to a general purpose computer where only the user experience would suffer.
\begin{quotation}
"Any information processing activity or system which has to respond to externally generated input stimuli within a finite and specified period." \cite{alan2001real}
\end{quotation}

Depending on the type of embedded system and the application area, timing delays leading to failures may also result in more serious consequences. Applications where a failure to respond within timing constraints (or an incorrect response is produced) results in a significant loss, or even life, are referred to as \textit{safety-critical systems}(cite SCJ spec). As a result of the possible consequences, safety-critical systems must go through a strict and rigorous certification and validation process before being put into use. One example of such certification processes is the \textit{Software Considerations in Airborne Systems and Equipments Certification} (DO-178B)\cite{DO178B}, that the \textit{Federal Aviation Administration} requires safety-critical software to be certified against within the United States (and equivalent is found in Europe). As an example, with the highest level of certification (level A) under DO-178B, the compiled object code must be analyzed in depth in order to verify correct behavior and to find and inspect all compiler made optimizations\cite{DO178B-Example}.

Currently developing safety-critical systems is done using languages in which there are little nondeterminism, such as the C or Ada (in the Ravenscar profile) programming languages, due to their ability to write predictable software as a result of, amongst other things, the manual memory management. This, however, also presents some challenges as with the great control that e.g. C provides, a greater responsibility in the development is put upon the programmer. One must deal with this manual memory management correctly such as ensuring the absence of buffer overflows and manually deallocating heap objects.
Recently, attempts have been made to bring Java into the area of real-time and safety-critical systems. Motivations for this are primarily grounded in its attractiveness due to its type-safety and widespread familiarity that supposedly leads to increased programmer productivity\cite{henties:2009-20}\cite{Nilsen96issuesin}. In other words, developing a system in a high-level language reduces the risk of making errors in the process, and this can be considered an extremely feasible goal to achieve for safety-critical system development.
The \textit{Safety-Critical Java} (SCJ) specification under \textit{JSR-302}\cite{JSR}(cite to spec), based on the existing \textit{Real-Time Specification for Java} (RTSJ), is an attempt to leverage the many benefits of Java for safety-critical system development, which require behavior and performance that is predictable as well as being reliable(cite spec). The primary goal of SCJ is to enable the development of applications that can be certified against rigorous certification processes such as DO-178B level A. As the specification is not yet completed, and still a draft, few implementations and use cases exists which are required in order to thoroughly evaluate the specification and validate its design.
In this study we wish to examine the development of real-time applications using SCJ, as well as contribute and complement the further development of SCJ from its current state. Java for real-time embedded and safety-critical systems is an important research area, and in the following sections we examine the current state of SCJ and identify some of the currently hot research topics in which this project may contribute.

\section{The Current State of SCJ}
In this Section we will briefly examine the current state of \textit{Safety-Critical Java} (SCJ) and topics that are open for work in order to find a suitable area to contribute in bringing Java into safety-critical systems. Note that this will not provide a thorough introduction to SCJ but rather serves to describe its presence.

\subsection{Brief History} % (fold)
\label{sub:brief_history_of_java_for_safety_critical_systems}
For several years Java has been widely applied in the industry as the programming language and platform for many software development projects. The \textit{standard edition} (SE) of Java, however, is not directly applicable in the area of real-time systems (and in particular safety-critical systems). The \textit{Real-Time Specification for Java} (RTSJ) under \textit{JSR-001}\cite{alan2001real}\cite{henties:2009-20} was a significant breakthrough that amongst other things specified constraints of Java in terms of thread scheduling and memory management that are necessary in order to meet the requirements for developing real-time systems. A number of virtual machines for RTSJ have been implemented and interesting use cases have been developed. Notable examples are experimenting with RTSJ for an unmanned aerial vehicle (UAV) at Boeing\cite{Armbruster:2007:RJV:1324969.1324974} and experimenting with the programming model in RTSJ for space missions, done in collaboration with NASA\cite{DBLP:conf/isorc/DvorakBCCCGIMMR04}. However, despite such prominent actors having invested time and effort into RTSJ, it has been the subject of much debate. Primarily, the application of RTSJ for e.g. safety-critical applications has been questioned due to its comprehensive size and complexity. As a result, attempts to simplify RTSJ have been made such as the Ravenscar Java profile and Safety-Critical Java in which the latter has become the most prominent one.

Safety-Critical Java was initiated in 2006 as JSR-302 led by "The Open Group", and the specification has been under development since then, with involvement from representatives from companies such as Boeing, Oracle and IBM. As stated, SCJ, is an attempt to simplify RTSJ - in fact it is designed as a subset of RTSJ. Figure \ref{img:java_versions_relationships.pdf} illustrates the relationship between the different Java editions.

\img{java_versions_relationships.pdf}{0.5}{The relationship between Java and the real-time specifications.}

Having just passed its 6th birthday, the specification is nearing its completion and is currently being finalised. This does not, however, mean that one can simply begin to develop SCJ applications, as there are still future work to be done. First, the specification requires some kind of validation in order to approve its application for safety-critical software. Second, as the specification originates back from 2006, many things have happened in the area since, and the surroundings (such as certification requirements) have changed in some areas which may allow easing some of the restrictions under which SCJ applications are developed. In the following we will look at some of these interesting topics that are open for work in relation to SCJ.

% subsection brief_history_of_java_for_safety_critical_systems (end)


\subsection{Hot Topics in the Community} % (fold)
\label{sub:interestingresearch}
As the SCJ specification is still in public draft and thereby under constant evaluation both from the outside world and within, "The Expert Group" urgently need independent implementations of it in order to refine it\cite{Schoeberl:2012:SCJonJava}. Currently at the time of writing, a limited open-source prototype implementation supporting non-complex SCJ applications is available under the name, oSCJ\cite{oSCJ}. As the implementation is extremely limited and because there is little to no activity in the code repository, it can be considered as being either in a hibernation state or shelved. Fortunately, another prototype implementation of SCJ that offers a larger subset of the specification to run on the \textit{Java Optimized Processor} (JOP), a hardware implementation of the JVM, is also available\cite{Schoeberl:2012:SCJonJava}. This implementation supports the creation and execution of more complex SCJ applications. Besides supporting the specification development by providing implementations of the specification, "The Expert Group" also needs more practical use cases of SCJ applications. In this regard, only two public available use cases have been developed, namely a desktop RepRap 3D printer\cite{Schoeberl:2012:RepRap} and a cardiac pacemaker\cite{Singh:2012:CPC:2388936.2388948}. The call for implementations and use cases is both present in many research papers covering the area, but also something that has been pointed out several times by our supervisor who has been attending the \textit{Java Technology for Real-Time and Embedded Systems} (JTRES) workshop several times, reinforcing the need.

Another interesting and highly debated area of research is in relation to the memory model. SCJ uses a rather special memory model in order to compensate the lack of automatic garbage collection. Furthermore using garbage collectors in real-time systems has not been considered a viable options up until now, due to timing and analysis difficulties leading to unpredictable behavior. Recently, however, there have been a breakthrough towards garbage collection in real-time and safety-critical applications, as \textit{ESA} has opened up for allowing such techniques(cite to doc). One can therefore insinuate that the memory model in SCJ is becoming outdated as it was designed under different circumstances. Incorporating a feasible garbage collector is, however, not a straightforward task as it entails overcoming several challenges such as specifying an acceptable release frequency, avoiding memory fragmentation and minimizing interference in terms of blocking. In relation to release frequencies a formula for calculating the highest possible release time, however with requirements\footnote{The application must only consist of hard read-time periodic tasks} posed on the SCJ application, exists but requires the maximum memory allocation consumption of all application threads to be known in advance\cite{Schoeberl:2007:GCS:1288940.1288953}. Naturally this also raises a need for tools that are able to compute these memory consumption values by e.g. analyzing the application source code. The memory management model is in general an interesting area with many open areas in which is is possible to contribute.

\section{GomSpace and the Cubesat Space Protocol} % (fold)
\label{sec:gomspace_and_the_cubesat_space_protocol}
Having just described some of the current hot topics, we see great opportunity in working with a use case that can benefit the further development of SCJ and its specification.

\textit{GomSpace ApS} is a university spin-off company currently residing in the NOVI Science Park, that is located in the same area as the Aalborg University campus. GomSpace specializes in space mission solutions with emphasis on Cubesat and nano-satellite platforms\cite{GomSpace}. The expertise of GomSpace in small satellite technology covers both electronic as well as software engineering competences. The entrepreneurs behind GomSpace has also been part of some of the Cubesat projects during their time of study at Aalborg University, that was successfully launched into space. In fact, they were part of the AAU-Cubesat which was the first Cubesat in Europe that was launched into space.

One of the key software elements in their repertoire is the \textit{Cubesat Space Protocol} (CSP). Started during their time as students, the CSP library is a small network-layer delivery protocol directly for Cubesats, that can allow distributed systems (such as the case of a space mission) to communicate using a simple API that closely resembles that of Berkeley sockets. Currently the library is implemented in C with much focus on small footprint and high performance. GomSpace, however, is interested in pushing for other possibilities in developing such software solutions in their area, which is inherently safety-critical. This includes interest in the possible use of Java technology due to the previously stated benefits (see Section \ref{chapter:introduction}) that may be harvested, and therefore for this study we have been able to work the GomSpace company to provide a use case of real safety-critical dimensions for SCJ.

% section gomspace_and_the_cubesat_space_protocol (end)

\section{Problem Statement} % (fold)
\label{sec:problem_statement}
Having examined the current state and open topics in the community surrounding the use of Java technology for safety-critical systems, we now turn to the clarification of a problem that we will base this study upon. In Section \ref{sub:interestingresearch} we listed some of the topics that we have seen, where putting in some work effort could lead to a contribution. One of these were the apparent lack of use cases and real applications of SCJ that one of the key people in the community, Martin Schoeberl, describe as necessary for proper evaluation and further development of the specification \cite{Schoeberl:2012:SCJonJava}. Combined with the opportunity of working with the people behind GomSpace who also has interest in this, and who also has real applications that are safety-critical, we consider a use case study of applying the SCJ in use a great opportunity.

We briefly mentioned the Cubesat Space Protocol. Because this is a central element in their space solutions, we choose to examine this protocol in depth and see how this can be transferred to SCJ. We would like to emphasize the opportunities that arise with the CSP in SCJ. First, the inherent ability to provide the use case for the community, which opens up for the opportunity to continue the work later with more applications by having the ability to communicate with existing modules in a space mission from SCJ applications. Choosing to implement CSP in SCJ may therefore also provide a ground for many other contributions in the community.

We have therefore reached the ability to state the following problem statement for this study:
\begin{quotation}
	\textit{Can the network-layer delivery protocol, Cubesat Space Protocol, be designed and implemented using Safety-Critical Java, such that it can be applied for applications that relies on communicating with peripheral modules in a safety-critical environment?}
\end{quotation}
In addition to the statement of the problem we wish to outline some of the key goals - i.e what we wish to examine as a part of this study.

An additional reason for working with this topic is in relation to our personal backgrounds. We have great interest in software development and believe that with our background in Software Engineering, which includes much experience working with Java and similar platforms, we are able to provide some reflection on applying SCJ from a developer perspective. As previously stated many of the motivations behind bringing Java technology to safety-critical systems is that of programmer productivity, as well as letting many of the Java developers out there develop safety-critical systems. Therefore as a part of the problem, we wish to examine this and in the end reflect upon SCJ from our point of view as a part of the use case. We can outline these additional questions:
\begin{itemize}
	\item When working with this use case, to what degree is it possible to apply existing Java experience to the development of safety-critical systems using SCJ?
	\item Are there elements in the specification that could be changed for the better?
	\item As CSP is effectively a library, which considerations must one take into account when developing libraries for SCJ in contrast to standard edition Java? Furthermore how can such libraries be made to ease the use for developers with prior Java experience?
	\item As a result of the use case, are there any topics or encountered issues that are worth examining in depth for future work?
\end{itemize}

Furthermore, in order to be able to reflect upon these questions and provide a conclusion for the problem statement, we have the goal of building an SCJ application on top of the implemented CSP protocol. This serves the goal of both validating the implementation of CSP, as well as being able to illustrate the development of a real-time safety-critical application using the CSP implementation, and how a Java developer would see this task.

% subsection method (end)

% subsection delimitation (end)

% subsection grounds_and_goals (end)

% section problem_statement (end)
