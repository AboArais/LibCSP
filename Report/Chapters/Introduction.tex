\chapter{Introduction}
\label{chapter:introduction}
Todays notion of a computer is often implicitly associated with general purpose computers such as desktops, laptops or even tablets. However, an estimated 99\% of the worlds production of microprocessors is for use in \textit{embedded systems}\cite{alan2001real}. Often, embedded systems are also \textit{real-time systems} as they involve temporal requirements. For instance, embedded real-time components in aircrafts must respond properly within strict timing constraints as delays or incorrect responses can lead to fatal consequences. Systems in which human lives are dependant on the functional behaviour, are referred to as \textit{safety-critical systems}\cite{SCJSpec}. As a result of the possible consequences, safety-critical systems must go through a strict and rigorous certification and validation process before being put into use. One example of such certification processes is the \textit{Software Considerations in Airborne Systems and Equipments Certification}~(DO-178B)\cite{DO178B}, that the \textit{Federal Aviation Administration} (FAA) requires safety-critical software to be certified against within the United States. As an example, with the highest level of certification (level~A) under DO-178B, the compiled object code must be analysed in depth, in order to verify correct behaviour and to find and inspect all compiler made optimisations\cite{DO178B-Example}.
		
Currently, developing safety-critical systems is done using languages in which there are little nondeterminism, such as the C or Ada (in the Ravenscar profile) programming languages, due to the predictable semantics as a result of, amongst other things, the manual memory management. As a consequence, one must e.g. ensure the absence of buffer overflows and manual deallocation of data objects.

Attempts have been made to enable the development of real-time and safety-critical systems using Java. Motivations for this are primarily grounded in its attractiveness due to its type-safety and widespread familiarity that supposedly leads to increased programmer productivity\cite{henties:2009-20, Nilsen96issuesin}. The \textit{Safety-Critical Java}~(SCJ) specification under \textit{JSR-302}\cite{JSR, SCJSpec}, based on the existing \textit{Real-Time Specification for Java}~(RTSJ)\cite{RTSJSpec}, is an attempt to leverage the benefits of Java for safety-critical system development. The primary goal of SCJ is to enable the development of applications that can be certified against rigorous certification standards such as DO-178B level~A. As SCJ is not yet completed, the area is still open for work.

In this project, we look at the development of safety-critical systems using SCJ. We will study SCJ through the implementation of a small network-layer delivery protocol to gain insight into the specification. Through the observations and results of this study we will identify areas of interest for future work that may contribute to the surrounding community of SCJ.

\section{Brief History of SCJ} % (fold)
\label{sub:brief_history_of_java_for_safety_critical_systems}
For several years Java has been widely applied in the industry as the programming language and platform for many software development projects. The \textit{standard edition} (SE) of Java, however, is not directly applicable in the area of real-time systems (and in particular safety-critical systems). Among other things, predictable execution is necessary for analysis. The \textit{Real-Time Specification for Java} (RTSJ) under \textit{JSR-001}\cite{alan2001real, henties:2009-20} was a significant breakthrough that, amongst other things, specified constraints for Java in terms of thread scheduling and memory management that are necessary in order to meet the requirements for developing real-time systems. A number of virtual machines for RTSJ have been implemented and interesting use cases have been developed. Notable examples are experimenting with RTSJ for an unmanned aerial vehicle (UAV) at Boeing\cite{Armbruster:2007:RJV:1324969.1324974} and experimenting with the programming model in RTSJ for space missions, done in collaboration with NASA\cite{DBLP:conf/isorc/DvorakBCCCGIMMR04}. However, despite such prominent actors having invested time and effort into RTSJ, it has been the subject of much debate. Primarily, the application of RTSJ e.g. for safety-critical applications, has been questioned due to its size and complexity. As a result, attempts to simplify RTSJ have been made such as the Ravenscar Java profile\cite{Kwon:2002:RHI:583810.583825}, Predictable Java\cite{Bogholm:2009:PJP:1620405.1620427} and SCJ in which the latter has become the most prominent one.

Safety-Critical Java was initiated in 2006 under JSR-302 as a subset of RTSJ with additional classes\cite{Schoeberl:2012:SCJonJava}. Led by the ``The Open Group'', with involvement from representatives from companies such as Boeing, Oracle and IBM, SCJ is currently being finalised, but requires validation in terms of implementations and use cases, in order to approve its application for safety-critical software.

%An explicitly stated need in the community is that of SCJ implementations and use cases\cite{Schoeberl:2012:SCJonJava} in order to evaluate and refine the specification.
At the time of writing two public, available SCJ implementations are found to be available. First, a limited open-source prototype implementation supporting non-complex SCJ applications is available under the name, oSCJ\cite{oSCJ}. However, this can be considered to be either in a hibernation state or shelved due to inactivity. Another prototype implementation of SCJ, that offers a larger subset of the specification, is available on the \textit{Java Optimized Processor}~(JOP), a hardware implementation of the JVM\cite{Schoeberl:2012:SCJonJava}. Besides supporting the specification development by providing implementations of the specification, practical use cases of SCJ applications have been developed. In this regard, two public, available use cases have been presented, namely a desktop RepRap 3D printer\cite{Schoeberl:2012:RepRap} and a cardiac pacemaker\cite{Singh:2012:CPC:2388936.2388948}\footnote{This use case can, however, be discussed if it can be classified as an SCJ application as they deviate from the specification.}. These use cases have been presented at the \textit{Java Technology for Real-Time and Embedded Systems}~(JTRES) workshop.

%The call for implementations and use cases is both present in many research papers covering the area, but also something that has been pointed out several times by our supervisor who has been attending JTRES several times, reinforcing the need.

%Another interesting and much debated area of research is in relation to the memory model. SCJ inherits from RTSJ, a special memory model in order to compensate the lack of automatic garbage collection. Furthermore using garbage collectors in real-time systems has not been considered a viable option until now, due to timing and analysis difficulties. Recently, however, there has been a breakthrough towards garbage collection in real-time and safety-critical applications, as \textit{ESA} has opened up for allowing such techniques(cite to doc). Incorporating a feasible garbage collector is, however, not a straightforward task as it entails overcoming several challenges such as specifying an acceptable release frequency, avoiding memory fragmentation and minimising interference in terms of blocking. In relation to release frequencies a formula for calculating the highest possible release time exists, however with requirements\footnote{The application must only consist of hard read-time periodic tasks} posed on the SCJ application. It requires the maximum memory allocation consumption of all application threads to be known in advance\cite{Schoeberl:2007:GCS:1288940.1288953}. Naturally this also raises a need for tools that are able to compute these memory consumption values by e.g. analysing the application source code. The memory management model is in general an interesting area with many open areas in which it is possible to contribute.

\section{GomSpace and the Cubesat Space Protocol} % (fold)
\label{sec:gomspace_and_the_cubesat_space_protocol}
\textit{GomSpace ApS} is a university spin-off company that specialises in space mission solutions with emphasis on Cubesat and nano-satellite platforms\cite{GomSpace}. One of the key software elements in their repertoire is the \textit{Cubesat Space Protocol}~(CSP). The CSP library is a small network-layer delivery protocol directly for Cubesats, that can allow distributed systems (such as the case of a space mission) to communicate using a simple API that closely resembles that of Berkeley sockets. Currently the library is implemented in C with much focus on small footprint and high performance. GomSpace, however, is interested in pushing for other possibilities in developing such software solutions in their area, which is inherently mission-critical. This includes interest in the possible use of Java technology due to the previously stated benefits that may be harvested. Therefore, for this study, we have been able to work with the GomSpace company, through the implementation of CSP in SCJ. 

% section gomspace_and_the_cubesat_space_protocol (end)

\section{Problem Statement} % (fold)
\label{sec:problem_statement}
We would like to emphasise the opportunities that arise with studying SCJ through the implementation of CSP. First, the ability to provide reflections on the use of SCJ and a use case for the community. Second, having a CSP implementation provides the opportunity to continue the work later with more applications by having the ability to communicate with other modules. Choosing to implement CSP in SCJ may therefore also provide a foundation for future work and other contributions in the community.

Based on this, we state the following problem statement for this project:
\begin{quotation}
	\textit{Can the network-layer delivery protocol, Cubesat Space Protocol, be designed and implemented using Safety-Critical Java, such that it can be used for applications that communicates with peripheral modules?}
\end{quotation}
The focus of working with this problem is to gain insight into SCJ and discover opportunities for additional work. Therefore, in addition to the statement of the problem we outline the following subsidiary goals and questions:
%An additional reason for working with this topic is in relation to our personal backgrounds. We have great interest in software development and believe that with our background in Software Engineering, which includes much experience working with Java and similar platforms, we are able to provide some reflection on applying SCJ from a developer perspective. As previously stated many of the motivations behind bringing Java technology to safety-critical systems is that of programmer productivity, as well as letting many of the Java developers out there develop safety-critical systems. Therefore as a part of the problem, we wish to examine this and in the end reflect upon SCJ from our point of view as a part of the use case. We can outline these additional questions:
\begin{itemize}
	\item When working with this use case, to what degree is it possible to apply existing Java experience to the development of safety-critical systems using SCJ?
	\item Are there elements in the specification that could be changed for the better?
	\item As a result of the use case, are there any topics or encountered issues that are worth examining in depth for future work?
\end{itemize}

Furthermore, we have the goal of building an SCJ application on top of the implemented CSP protocol. Prior to the work started in this project we constructed a watchdog application in SCJ that monitors modules in a distributed system. As this is based on pinging other modules, this is an ideal task to use CSP for. The previously constructed watchdog will be made in a version that utilises the implementation of CSP.

\subsection{Approach} % (fold)
\label{sub:method}
As indicated, working on this problem to gain insight in SCJ and finding areas for future work, is primarily based on gaining empirical knowledge. Before beginning the development we will make a survey on related topics to gain fundamental knowledge. In the following we outline the remaining parts of this report that reflects the approach for solving the stated problem:
\begin{description}
	\item[Chapters 2 and 3] We begin with a literature review on fundamental background theory. This provides definitions on central concepts that are used in terms of embedded, real-time and safety-critical systems. Next we will perform a review of the current draft version of the SCJ specification. We will here describe the major parts of developing SCJ applications and significant differences from standard edition Java.
	\item[Chapters 4 and 5] With the general theory and SCJ described we introduce the JOP platform used and the original CSP used for reference.
	\item[Chapter 6]  In this chapter we will describe the design and implementation of CSP in SCJ.
	\item[Chapters 7 and 8] Having implemented CSP in SCJ we provide reflections, findings and proposals for future work. This will be the presentation of the empirical knowledge gained throughout the project.
\end{description}

% noget med hvordan vi vil gribe det an
% noget med det er en empirisk process


