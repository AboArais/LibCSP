\section{From RTSJ to SCJ}
\label{section:scjreflecton}
Traditionally, safety-critical systems have been constructed using the cyclic executive scheduling approach. However, a gradual shift towards the use of concurrency has lead to more complex safety-critical systems. This has resulted in programming models where simple concurrent activites have become viable in the development of safety-critical systems. As a result, there has been a migration from \textit{deterministic} scheduling to \textit{predictable scheduling}, where verification is done through schedulability analysis such as the response time analysis. This verification is then typically appended as evidence in the certification process. We here consider some of the motivations behind the presented programming model in SCJ.

\subsection{General Concurrency Model} % (fold)
In general, the two concurrency models, \textit{thread-based} and \textit{event-based} exists. In the thread-based model a single thread of control is used for each entity. In the event-based model, an event handler begins executing in response to an event being fired. In SCJ, the concurrency model is based on an event-based approach (almost) exclusively. This is in contrast to RTSJ which incorporates both models. Let us consider some of the motives behind this restriction.

First, In RTSJ one can implement both heap and no-heap (i.e. never allocates any objects) real time threads, as well as heap and no-heap event handlers with little restrictions. As a consequence, it can be more difficult to construct the application and awkward cases in which a single release is associated with mixed responsibilies that ideally should be placed in different releases is permitted. As a result, the application becomes more complex to analyse and thereby verify its schedulability. Consider the example of a periodic task implemented in RTSJ, listed in Listing \ref{periodicrtsjtask} (the example is adapted from an RTSJ application provided in \cite{Schoeberl:2007:GCS:1288940.1288953}). Not only does this implementation contain two different units of work to be performed on a release (\code{doModeAWork} and \code{doModeBWork}) depending on a manually maintained state. Analysis also becomes more complex by the unbounded loop and the \code{waitForNextPeriod} method that blocks the thread until its next release.

\lstinputlisting[language=Java,label=periodicrtsjtask,caption=An example of a periodic task in RTSJ]
{Code/Concurrency/concurrency_periodic_rtscj.java}

In SCJ this is simplified. As event handlers are released by the underlying infrastructure, only the logic for a release need to be implemented in the \code{handleAsyncEvent} method. This makes it more easy to perform analysis as well as support static analysis tools.

A second motivation for an event-based model, is that of binding threads. In RTSJ an asynchronous event handler always executes under the control of a thread, however, when this binding occurs is not specified. This can either happen just before the release (allowing reuse of threads for different handlers) in which the event handlers are \textit{unbound}. Otherwise , the asynchronous event handler may also be \textit{bound} permanently to a thread upon creation. The important part of this, is that asynchronous event handlers are effectively real-time threads and is no different in terms of scheduling. There is therefore no significant drawback in using asynchronous event handlers from an underlying implementation point of view. This supports the first motivation for using the event-based model. In addition, only bound asynchronous event handlers are allowed, as this is more predictable considering no latency occurs due to the need for binding upon release.

\subsection{Sporadic Tasks} % (fold)
\label{sub:support_for_sporadic_tasks}
While RTSJ supports all three types of tasks, SCJ is restricted to periodic and aperiodic tasks. Therefore no enforcement of minimum inter-arrival times between release events is present, and this relies on the application developer. It is not evident why sporadic handlers are not supported, however, overhead in run-time timing checks may be an obvious reason. Similarly issues with \textit{jitter} may further the complexity of this task, thus result in less predictability. As a result, one must model sporadic tasks as aperiodic event handlers instead. On the other hand deadline miss detection is faciliated, which can be considered somewhat peculiar as this is concerned with the same mechanics.

\subsection{Scheduling and Priority Inversion Avoidance} % (fold)
\label{sub:scheduling_and_priority_inversion_avoidance}
The use of a preemptive fixed-priority scheduler is equivalent to the scheduling specified in RTSJ. Because of support for communication between schedulable objects in SCJ, a priority inversion management protocol is necessary. SCJ explicitly uses \textit{Priority Ceiling Emulation} (otherwise known as \textit{Immediate Ceiling Priority Protocol}, ICPP). This is different from RTSJ in which inheritance is the standard protocol, and the ceiling protocol may be used optionally. As a result, whenever a task locks a resource (such as when successfully invoking a synchronised method), its priority is raised to the ceiling of that particular resource. The ceiling priority of each resource is defined as the maximum of all tasks that uses it. As a result, a task can only be blocked once at the beginning of its execution and then be able to continue without interruptions unless a higher priority task is released. For additional information on different priority avoidance protocols and their differences we refer to \cite{alan2001real} as this is beyond the scope of this report.

It is clear that many of the restrictions are defined in order to simplify the whole infrastructure and make it more predictable. For instance, it is known that the Priority Ceiling Emulation has the benefit of being more easy to implement, but also leads to fewer context switches and ensures the absence of deadlocks\cite{alan2001real}. However, this also comes at the cost of not being allowed to invoke self-suspending calls in handlers such as \code{Object.wait} unless it is a level~2 application. A consequences of this, is that for many data structures such as a queue, in which a Java programmer would normally use \code{Object.wait} and \code{Object.notify}, one must think differently.

% subsection scheduling_and_priority_inversion_avoidance (end)

% subsection support_for_sporadic_tasks (end)