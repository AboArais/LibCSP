\section{The Programming Model}
\label{section:programmingmodel}
The programming model of SCJ can be considered being much more strict than its predecessor, RTSJ, which has been criticised for being too complex and difficult to certify under rigid standards such as the DO-178B level A - something that was also mentioned in Section \ref{sub:brief_history_of_java_for_safety_critical_systems}. This simplification naturally poses restrictions on the developer in terms of how code must be structured within a SCJ application, but fortunately eases the whole certification process. Furthermore, by forcing the developers to adhere to a general programming model as well as having special annotations for vendor-supplied third-party tools, that are able to analyse correctness properties of the source code depending on the different use contexts, all helps in simplifying the certification. This Section will describe the programming model in SCJ and the rationale behind some of the decisions and concepts.


\subsection{Missions}
As a requirement and as the back-bone of every SCJ application, an application must consist of at least one \textit{mission}. \code{Missions} can be regarded as entities encapsulating specific responsibilities of the overall application. This is much in accordance with the Object-Oriented Programming (OOP) principles of dividing code into classes having specific purposes. The granularity of encapsulation and thereby separation of concern is, however, often broader in \code{missions} as each mission can take the responsibilities of several tasks that are confined to a specific domain. As an example, consider the software for an unmanned rover taking earth samples on Mars. The rover needs to perform several vital functions in order to complete its objectives. The functionality can roughly be divided into:

\begin{itemize}
	\item Detach from charge station
	\item Navigate the environment to specific locations
	\item Align mounted solar panels to optimal positions throughout operation to prolong battery life
	\item Obtain earth samples
	\item Communicate results to outside world
	\item Drive back and attach to charge station
\end{itemize}

The above functionality could be represented in five different missions with coordination taking place in between. Each mission would in turn contain a number of \textit{schedulable objects} (threads) refereed to as \textit{event handlers}. These will be described in the next section. "The Expert Group" behind the specification decided to include the \code{mission} concept as a solution to the problem of some modern safety-critical monolithic applications consisting of millions of lines of code making them very complex to maintain and certify. Also by dividing the application into one or more \code{missions}, each \code{mission} could be developed independently and in isolation from the others.  

To create a \code{mission} class in SCJ it must extend the abstract \code{Mission} and override the two abstract methods, \code{initialize} and \code{missionMemorySize}. In \code{initialize}, the mission context is prepared which includes creating the underlying \textit{schedulable objects} and possibly various shared data structures. In \code{missionMemorySize}, the maximum memory space for the \code{mission} is defined (in bytes).

Returning back to the rover example, a possible \code{mission} for the solar panel functionality, could look like that seen in Listing \ref{missionexample}.

\lstinputlisting[label=missionexample,caption=Example of a mission for the Mars rover.]{Code/mission.java}

The reason for explicitly stating the memory consumption is due to the absence of automatic garbage collection. Furthermore as memory in real-time systems often is a limited resource, this number should be assigned with care by analysing the contained code.

\subsubsection{Life Cycle}
\label{subsec:lifecycle}
The concept of a \textit{mission life cycle} covers the different phases a mission can be situated in throughout its "life time". Figure \ref{img:scj_mission_lifecyle.pdf} shows the various phases of the life cycle.

\img{scj_mission_lifecyle.pdf}{0.6}{The mission life cycle.}

Once the application starts to execute, a single mission is selected from all defined missions, by a \textit{mission sequencer}, that oversees the execution of each \code{mission}. Next the \code{mission} is initialised which involves calling the \code{initialize} method on the mission (see Listing \ref{missionexample}) that, amongst other things, registers the defined \code{schedulable objects}. Internally these are descendants of the class, \code{ManagedScheduable}. 

Upon transitioning from the \textit{initialisation phase} to the \textit{execution phase}, the \code{schedulable objects} are scheduled by the underlying fixed-priority scheduler. Note that \code{schedulable objects} residing in other missions cannot be scheduled at this time, but only those defined in the currently selected \code{mission}. Before terminating the currently executing mission and switching to the next, i.e. after every \code{schedulable object} within the \code{mission} have terminated, a \textit{clean up phase} occurs in which \code{mission} related clean up code can be executed. In order to do so, the following method must be overridden from \code{Mission:}

\begin{quotation}
	\code{protected void cleanUp();}
\end{quotation}

\subsection{Handlers}
\label{subsection:handlers}
A \code{mission} in itself does not do much apart from creating \code{schedulable objects} and allocating shared data structures. The functional behaviour of a \code{mission} happens through the \code{schedulable objects}, which are basically implemented as threads that operates as event handlers. The event handlers can be either periodic or aperiodic (sporadic tasks are not supported in SCJ). In the \code{initialize} method of the solar panel \code{mission} for the Mars rover in Listing \ref{handlerIns}, a periodic event handler could be instantiated and registered.

\lstinputlisting[label=handlerIns,caption=Instantiation and registration of a periodic event handler for the Mars rover.]
{Code/handlerInstantiated.java}

The supplied arguments denote its priority (\code{PriorityParamenters}), release offset and frequency (\code{PeriodicParameters}) and various storage parameters. Storage and memory management is an important aspect in SCJ and is something that will be elaborated in greater detail in Section \ref{section:memoryManagement}. The handler class itself, being its a periodic event handler, must extend the class \code{PeriodicEventHandler}. Aperiodic event handlers similarly extends \code{AperiodicEventhandler}. As a minimum requirement, the handler class must have a constructor accepting the above mentioned parameters that will be passed to its immediate base class, but also override another method called \code{handleAsyncEvent} in which execution logic occur. The event handler from Listing \ref{handlerIns} could be defined as seen in Listing \ref{handlerDef}.

\lstinputlisting[label=handlerDef,caption=Definition of the periodic event handler for the Mars rover.]
{Code/handlerDefinition.java}

\subsection{Safelet}
\label{subsection:safelet}
The application defining class of a SCJ application is represented by a user-defined implementation of the so-called \textit{Safelet} interface, which identifies the outer-most \code{mission sequencer} and like the \code{mission}, also the maximum storage space. The \code{safelet} implementation for the Mars rover can be seen in Listing \ref{safeletRover}.

\lstinputlisting[label=safeletRover,caption=Safelet implementation for the Mars rover.]
{Code/safelet.java}

In Line 7, an array of \code{missions}, initialised with all the missions , is allocated. This array is then given as an actual parameter, together with the priority and storage capacity, to a \code{RepeatingLinearSequencer}, which inherits from \code{MissionSequencer}. The sequencer, then repeatedly loops through the contained \code{missions}. In traditional Java programs, execution begins with a call to the mandatory static main method, however, the start-up sequence for SCJ applications is a bit more complicated. According to the SCJ specification, the \code{safelet} instantiation is \textit{implementation defined}. It is thus up to the different vendors to bootstrap the application.

\subsection{Application Start-Up Flow}
Having described the overall constituting components of a SCJ application, Figure \ref{img:scj_init_phase.pdf} abstractly summarises the initial flow from when an application is started up until prior thread execution. In reality, this is much more complex underneath, for additional details we refer to the specification. As can also be seen, levels define what happens during the startup and execution and what is allowed. In the following section these differences will be highlighted.

\img{scj_init_phase.pdf}{0.8}{Start-up flow of a SCJ application.}