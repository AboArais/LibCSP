\section{Compliance Levels}
\label{section:complianceLevels}
Although the Safety-Critical Java specification was developed with simplification in mind, the complexity across different applications can vary greatly. One application may for example contain a single periodic event handler performing some trivial operation whereas another application may contain multiple periodic and aperiodic event handlers executing under strict timing constraints, performing complex operations and with synchronisation in between. In order to minimise the certification process, the specification was created in a way such that simple applications do not have to suffer with a resource heavy infrastructure and an equally heavy Java run-time environment each causing extra certification effort. The financial cost of certifying a SCJ application, and any safety-critical application for that matter, namely depends on its complexity. The more complex the application is, the more expensive and longer it takes to certify it. The Safety-Critical Java specification defines three levels for this purpose that are referred to as, \textit{compliance levels}. The levels are denoted \textit{level 0}, \textit{level 1} and \textit{level 3} respectively where simple applications may conform to level 0 and complex ones to level 3. It is thus desirable to minimise the compliance level as much as possible as the expected price for a level 3 application should be higher then that of a level 0 application. It should be noted that compliance levels are \textit{not} related to the criticality levels from the previously mentioned DO-178B standard. The following three subsections will elaborate on the different compliance levels starting with the lowest.

\subsection{Level 0}
A level 0 application executes under the cyclic executive model that was described in Section \ref{subsec:cyclicExecutive}. Each mission within the application is basically broken down into fixed size computation parts and run in sequence. It is up to the developer to create the schedule, which entails creating the frames, distributing the computation parts (event handlers) amongst the frames, and setting the frame durations. Figure \ref{img:level0.pdf} shows a graphical example of an execution schedule consisting of four event handlers that are confined to a single mission. Moreover, the schedule consists of three frames (the minor cycles) containing, one, two and one event handler(s) respectively. The durations of the frames varies and some of them have more idle time than others\footnote{This is just one example of a possible schedule as others exist.}. Notice that each event handler is assigned a unique priority, however, when executing the application as a level 0 application, the priorities are disregarded. Should the application run under a higher compliance level such as 1 or 2, the priorities are taken into account. 

\img{level0.pdf}{0.8}{A level 0 application running under the cyclic executive scheduling model.}

Normally in concurrent programs, event handlers (threads) are interleaved which gives an illusion of parallelism. In the cyclic executive approach, however, event handlers run in sequence within their respective frames and thereby also till completion - i.e. no preemption occurs. Although this has the benefit of being able to omit synchronisation mechanisms, supporting synchronisation is still advised, should the application run at a higher compliance level. Naturally, as each periodic event handler is run in sequence, a handler should not invoke \code{Object.wait} and \code{Object.notify} as well as any blocking statement (doing so, breaks the schedule). If this requirement is satisfied and the developer has properly fitted the event handlers into frames, the schedule is considered valid and requires no additional schedulability test.

\subsection{Level 1}
