\section{Memory Management}
\label{section:memoryManagement}
Memory models for real-time and safety-critical systems is a hot topic and an area that is subject to much discussion. This comes as a result of the desire to provide as much abstraction and automatic memory management as possible. In order to avoid manual memory management, but still achieve predictable behaviour, SCJ employs a memory model inherited from RTSJ but in a more strict refinement.

In general, the notion of a heap is gone and so is the garbage collector that handles automatic memory management for the developer. Instead, SCJ employs a scoped-memory model in which all allocated objects in an allocation context (or a scope) are bulk deallocated when the context (or scope) exits. A scoped memory area in SCJ is thereby a region that supports linear time allocation of objects and bulk deallocation\cite{Schoeberl:2007:GCS:1288940.1288953}. In the following we describe the general semantics of this model.

\subsection{Scoped Memory Model} % (fold)
\label{sub:scoped_memory_model}
The details of the memory model is closely related to the mission life cycle, which was described in Section \ref{subsec:lifecycle}. Overall an application consists of at least three different allocation contexts, or memory scopes. The first named area is \textit{immortal memory} that is also found in RTSJ. This contains static fields and initial objects created such as the safelet. Any objects allocated in this area, during \textit{initialization} phase, will persist throughout the entire execution, that is, across missions. \textit{Mission memory} is the second memory area, that exists throughout a single mission. Allocations in this area happen during the mission \textit{initialization} phase and is available in all handlers that execute under the mission. Finally, there is the anonymous \textit{private memory} area. When a handler is released it is provided with an initial private scope, that will exist during that release. Additionally, it is possible to enter further nested private scopes. In any of these scopes, once the scope exits, any objects allocated in that memory area are deallocated. For handlers, this occurs when the \code{handleAsyncEvent} method returns, for missions when they terminate and for the immortal memory area when the application terminates. Figure \ref{img:memoryhierarchy.pdf} illustrates the concept of scoped memory and the hierarchy that the different areas shape for a level~1 application.

\img{memoryhierarchy.pdf}{0.8}{Examples of memory areas in a level 1 SCJ application.}

In fact, the illustrated hierarchy is explicitly maintained and used to perform scope checks at runtime by the infrastructure. This is to ensure that no \textit{dangling} pointers exists, in the case of assigning an object allocated e.g. in a private memory area, to a field that resides in mission memory\cite{Schoeberl:2011:MMS:2043910.2043919}. When said private scope exits, the field would point to a non-existing object as it would be deallocated.

% Memory artiklen detaljer

\subsection{Considerations of Scoped Memory} % (fold)
\label{sub:considerations_of_scoped_memory}
The use of the scoped memory model is a clear compromise between achieving the predictable behaviour of manual memory management and the developer benefits of automatic memory management. As a result, some considerations force SCJ developers to think differently compared to standard edition Java.

In Java, many operations and standard libraries rely on creating temporary objects that will be automatically collected by the garbage collector. Because the allocation context is now the important part of allocating objects dynamically, many of the usual development habits and standard libraries are invalidated or made troublesome to use. This was also highlighted as an issue in the RepRap 3D Printer use case\cite{Schoeberl:2012:RepRap}. Consider the example SCJ application consisting of a single mission with a single periodic handler in Listing \ref{stringappendexample}. 

\lstinputlisting[language=Java,label=stringappendexample,caption=Trivial use of Java String operations in SCJ.]
{Code/StringAppendExample.java}

An otherwise innocent use of the append method on a \code{String} object will in this case result in a \code{MemoryAccessException} during the fourth release of the handler, because the original \code{StringBuilder} object was allocated in Mission memory. Therefore, a challenge lies in the construction of packages for SCJ if other developers should be able to use these, as in standard edition Java (or as close as possible).

Another issue, related to the scoped memory model, is also demonstrated through the previous \code{String} append example. In order to achieve e.g. the DO-178B level~A certificate, one must prove the absence of runtime exceptions\cite{Schoeberl:2007:GCS:1288940.1288953}. How this is done, is left to the developer, and considering the previous example in which it may be difficult to spot the possible \code{MemoryAccessException}, this is a difficult task to achieve. This is also part of the motivation behind recent attempts of realising garbage collection, suitable for safety-critical applications. We conclude this introduction to the memory model by emphasising that memory models for real-time and safety-critical systems is an area that is open for much work. In addition, considering the recent opening towards garbage collection as stated in Section \ref{sub:interestingresearch}, the area will continue to receive significant activity.