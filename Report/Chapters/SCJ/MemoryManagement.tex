\section{Memory Management}
\label{section:memoryManagement}
Memory models for real-time and safety-critical systems is a hot topic and an area that is subject to much discussion. This comes as a result of the desire to provide as much abstraction and automatic memory management as possible. Techniques for achieving those features (such as the use of garbage collection) are, however, in conflict with the requirements for developing safety-critical systems. In order to avoid manual memory management, but still achieve predictability, the authors of SCJ employs a memory model that is a more strict refinement of the one used in RTSJ.

In general, the notion of a heap is gone and so is the garbage collector that handles automatic memory management for the developer. Instead, SCJ employs a scoped-memory model in which all allocated object in an allocation context (in this case, a scope) are bulky deallocated when the context (or scope) exits. A scoped memory area in SCJ is thereby a region that supports linear time allocation of objects and bulk deallocation\cite{Schoeberl:2007:GCS:1288940.1288953}. In the following we describe the general semantics of this model, followed by example applications that demonstrates the inner workings.

\subsection{Scoped Memory Model} % (fold)
\label{sub:scoped_memory_model}
The details of the memory model is closely related to the mission life cycle, which was described in Section \ref{subsec:lifecycle}. Overall an application consists of three different allocation contexts, or memory scopes. The first named area is \textit{immortal memory} that is also found in RTSJ. This contains static fields and initial objects created such as the safelet. Any objects allocated in this area will persist throughout the entire execution, that is, across missions. \textit{Mission memory} is the second memory area, that exists throughout a single mission. Allocations in this area happens during the mission initialisation phase and is available in all handlers that executes under the mission. Finally, there is the anonymous \textit{private memory} area. When a handler is released it is provided with an initial private scope, that will exist during that release. Additionally, it is possible to enter further nested private scopes. In any of these scopes, once the scope exists, any objects allocated in that memory area is deallocated. For handlers, this occurs when the \code{handleAsyncEvent()} method returns, for missions when they terminate and for the immortal memory area when the application terminates. Figure \ref{img:memoryhierarchy.pdf} illustrates the concept of scoped memory and the hierarchy that the different areas shape for a level 1 application.

\img{memoryhierarchy.pdf}{0.8}{Examples of memory areas in a level 1 SCJ application.}

In fact, the illustrated hierarchy is explicitly maintained and used to perform scope checks at runtime by the infrastructure. This is to ensure that no \textit{dangling} pointers exists, in the case of assigning an object allocated in e.g. a private memory area to a field that resides in mission memory\cite{Schoeberl:2011:MMS:2043910.2043919}. When said private scope would exit, the field would point to a non-existing object as it would be deallocated.

% Memory artiklen detaljer

\subsection{Considerations of Scoped Memory} % (fold)
\label{sub:considerations_of_scoped_memory}
The use of the scoped memory model is a clear compromise between achieving the predictable behaviour of manual memory management and the developer benefits of automatic memory management. As a result, some considerations forces SCJ developers to think differently compared to standard edition Java.

In Java, many operations and standard libraries relies on creating temporary objects that will be automatically collected by the garbage collector. Because the allocation context is now the important part of allocating objects dynamically, many of the usual development habits and standard libraries are invalidated or made troublesome to use. This was also highlighted as an issue in the RepRap 3D Printer use case\cite{Schoeberl:2012:RepRap}. Consider the example SCJ application consisting of a single mission with a single periodic handler in Listing \ref{stringappendexample}. 

\lstinputlisting[label=stringappendexample,caption=Trivial use of Java \code{String} operations in SCJ.]
{Code/StringAppendExample.java}

An otherwise innocent use of the append method on a \code{String} object will in this case result in a \code{MemoryAccessException} during the fourth release of the handler, because the original \code{StringBuilder} object was allocated in Mission memory. Therefore, a challenge lies in the construction of packages for SCJ that other developers could use like in standard edition Java (or as close as possible).

Another important issue related to the scoped memory model is also demonstrated through the previous \code{String} append example. In order to achieve e.g. the DO-178B level A certificate, one must prove the absence of runtime exceptions\cite{Schoeberl:2007:GCS:1288940.1288953}. How this is done, is left to the developer, and considering the previous example in which it may be difficult to spot the possible \code{MemoryAccessException}, this is a difficult task to achieve. This is also part of the motivation behind recent attempts of realising garbage collection, suitable for safety-critical applications. We conclude this introduction to the memory model by emphasising that memory models for real-time and safety-critical systems is an area that is open for much work. In addition, considering the recent opening towards garbage collection as stated in \ref{sub:interestingresearch}, the area will continue to receive significant activity.