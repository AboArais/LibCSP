\section{Memory Management}
\label{section:memoryManagement}
Memory models for real-time and safety-critical systems is a hot topic and an area that is subject to much discussion. This comes as a result of the desire to provide as much abstraction and automatic memory management as possible. Techniques for achieving said features (such as the use of garbage collection) are, however, in conflict with the requirements for developing safety-critical systems. In order to avoid manual memory management, but still achieve predictability, the authors of SCJ employs a memory model that is a more strict refinement of that found in RTSJ.

In general, the notion of a heap is gone and so is the garbage collector that handles automatic memory management for the developer. Instead, SCJ employs a scoped-memory model in which all allocated object in an allocation context (in this case, a scope) are bulky deallocated when said context (or scope) exits. A scoped memory area in SCJ is thereby a region that supports linear time allocation of objects and bulk deallocation\cite{Schoeberl:2007:GCS:1288940.1288953}. In the following we describe the general semantics of this model, followed by example applications that demonstrates the inner workings.

\subsection{Scoped Memory Model} % (fold)
\label{sub:scoped_memory_model}
The details of the memory model is closely related to the mission life cycle that was described in Section \ref{section:programmingmodel}. Overall an application consists of three different allocation contexts, or memory scopes. The first named area is \textit{immortal memory} that is also found in RTSJ. This contains static fields and and initial objects created such as the safelet. Any objects allocated in this area will persist throughout the entire execution, that is, across missions. \textit{Mission memory} is the second named memory area, that exists throughout a single mission. Allocations in this area happens during the initialisation phase, and objects allocated area available in all handlers that executes under the mission. Finally, there is the anonymous \textit{private memory} area. When a handler is released it is provided with an initial private scope, that will exist during that release. Additionally, it is possible to enter further nested private scopes. In any of these scopes, once the scope exists, any objects allocated in that memory area is deallocated. For handlers, this occurs when the \code{handleAsyncEvent()} method returns, for missions when they terminate and for the immortal memory area when the application terminates. Figure \ref{img:memoryhierarchy.pdf} illustrates the concept of scoped memory and the hierarchy that the different areas shape for a level 1 application.
\img{memoryhierarchy.pdf}{1.0}{Examples of memory areas in a level 1 SCJ application.}
In fact, the illustrated hierarchy is explicitly maintained and used to perform scope checks at runtime by the infrastructure. This is to ensure that no \textit{dangling} pointers exists, in the case of assigning an object allocated in e.g. a private memory area to a field that resides in mission memory. When said private scope would exit, the field would point to a non-existing object as it would be deallocated.

% Memory artiklen detaljer
% Problematikker med denne - append eksemplet og ref til GC artiklen