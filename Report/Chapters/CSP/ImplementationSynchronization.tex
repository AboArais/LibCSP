\subsection{Synchronization} % (fold)
\label{sub:synchronization}
Synchronization is performed throughout the implementation in order to provide a thread-safe API, as well as avoiding race conditions as a result of multiple handlers executing internally in the implementation. In the current version use, methods that require mutual exclusion are synchronized methods such that the particular objects act as monitors. Because the \code{synchronized} statement is not allowed in SCJ applications, regardless of compliance level, only synchronized methods are used to ensure mutual exclusion.

The queue data structure is a an example where this is needed. All available operations are thus synchronized. The public dequeue operation, however, is the only method that is not marked \code{synchronized}. Because \code{Object.wait} is prohibited in level 1, the dequeue operation cannot call this, thereby releasing its lock, and await a notify  when a queue element is available from another handler, performing an enqueue operation. Therefore the operations performing the actual dequeue of an element is implemented in a private synchronized dequeue method. The public dequeue method calls this repeatedly until an element is returned or the timeout passes. By also performing the busy wait on an element in a synchronized method, no other handler would ever be able to enqueue a data element while a handler performed a dequeue operation with a timeout. A tradeoff for this is the continous acquiring and release of the lock, if the dequeue operation is invoked with a timeout and not just a single attempt.

Ensuring thread-safety for the queues in resource pools could also be done by either letting the retrieve and put operations on the \code{ResourcePool} be synchronized methods. However, this results in all handlers needing the same lock regardless of which pool an object should be returned to or retrieved from. Because the \code{synchronized} statement is prohibited in SCJ level 1 applications, each the put and retrieve methods in \code{ResourcePool} cannot synchronize on an individual queue either. Therefore, it is the methods on the \code{Queue} class that is marked as synchronized. This provides better throughput as multipled handlers may access different queues concurrently. Another challenge is that of having multiple handlers working on the same socket or connection. This presents several race conditions, e.g. if one starts closing a connection while another uses it. This could e.g. result in the routing handler putting incoming packets into an already closed connection. Therefore several methods on these classes are marked as synchronized as well.

In general, the use of synchronization through Javas monitors has been heavily applied. The tasks are now dependant on each other and blocking caused by awaiting a lock must be taken into account during analysis of a client application. While e.g. the response-time analysis can be extended for this\cite{alan2001real}, this synchronization complicates the analysis. We return to this issue in Chapter \ref{chapter:Reflection}.