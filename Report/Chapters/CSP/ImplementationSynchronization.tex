\subsection{Synchronisation} % (fold)
\label{sub:synchronization}
Synchronisation is performed throughout the implementation in order to provide a thread-safe API, as well as avoiding race conditions that may occur in concurrent applications when multiple handlers share resources. Methods that require mutual exclusion are synchronised methods such that the particular objects act as monitors. Because the \code{synchronized} block-statement is not allowed in SCJ applications, regardless of compliance level, only synchronised methods are used to ensure mutual exclusion.

The queue data structure is a an example where synchronisation is needed and as a result, nearly all available operations must be synchronised. The public dequeue operation, however, is the only method that is not marked as \code{synchronized}. Because \code{Object.wait} is prohibited, the dequeue operation cannot call this in case the queue is empty, thereby releasing its lock, and await a notify when a queue element is available from another handler, performing an enqueue operation. Therefore the operations performing the actual dequeue of an element is implemented in a private synchronised dequeue method. The public dequeue method calls this repeatedly until an element is returned or the timeout passes. By performing the busy wait around a synchronised method, no other handler would ever be able to enqueue a data element while a handler performed a dequeue operation with a timeout. 


A tradeoff for this is the continous acquiring and release of the lock, if the dequeue operation is invoked with a timeout and not just a single attempt.

Ensuring thread-safety for the queues in resource pools could also be done by either letting the retrieve and put operations on the \code{ResourcePool} be synchronized methods. However, this results in all handlers needing the same lock regardless of which pool an object should be returned to or retrieved from. Because the \code{synchronized} statement is prohibited, each put and retrieve method in \code{ResourcePool} cannot synchronize on an individual queue either. Therefore, it is the methods on the \code{Queue} class that is marked as synchronized. This provides better throughput as multipled handlers may access different queues concurrently. Another challenge is that of having multiple handlers working on the same socket or connection. This presents several race conditions, e.g. if one starts closing a connection while another uses it. This could e.g. result in the routing handler putting incoming packets into an already closed connection. Therefore several methods on these classes are marked as synchronized as well.

In general, the use of synchronization through Javas monitors has been heavily applied. The tasks are now dependant on each other and blocking time must be taken into account during analysis of a client application. While e.g. the response-time analysis can be extended for this\cite{alan2001real}, this synchronization complicates the analysis. We return to this issue in Chapter \ref{chapter:Reflection}.