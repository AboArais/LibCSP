\subsection{Queue Data Structure} % (fold)
\label{sub:queue}
At several places in the C implementation, \textit{queue} data structures, are allocated during initialisation. Despite being used for holding common elements such as connections and packets, they possess another important role - information exchange and safe communication between threads. As an example, consider a user-defined thread hosting a server application that invokes the \code{csp\_accept} function. This causes the thread to wait (infinitely or for some specified period of time) for a new incoming connection by trying to dequeue its empty local connection queue. When a client wants to establish a connection to the server and sends the first packet through the network, the packet is received and forwarded to the routing tasks packet queue. During packet processing, a new connection element is established in which the packet is enqueued. The connection is then enqueued in the servers connection queue, which wakes up the server thread to fulfil the dequeue operation. Listing \ref{cqueue}, shows how threads communicates through queue operations by waiting and waking each other up based on queue conditions. 

\lstinputlisting[label=cqueue,caption=Simplified enqueue and dequeue operations in the C implementation of CSP.]{Code/Implementation/cqueue.c}

To model a similar behaviour in SCJ, for dealing with sockets, connections and packets some of the same mechanisms can be utilised - i.e. having queues in conjunction with handler communication. Invocations of \code{Object.wait}, \code{Object.notify} and \code{Object.notifyAll}, are not allowed in compliance level 1, so other means of enabling communication is required. To circumvent this, we create a new queue, which can be polled until a successful dequeue operation occurs or until some timeout (possibly none) takes place. The queue could be implemented as a simple \code{ArrayList}, however, only arrays are available in the compliant Java version (1.1). Instead we will create a \code{Queue} class with our own underlying data structure for storage. As the queue needs to be able to cope with different elements of different types (\code{SocketCore}, \code{ConnectionCore} and \code{PacketCore}), it is created as a generic class that takes a type parameter \code{T}, specifying the data type stored. Again due to language version limitations, an inner class, \code{Element}, is created that contains an element and a reference to the next element. This is a result of generic arrays not being available in the used version of Java. In other words, it resembles a circular buffer. References to the \textit{start}, \textit{head} and \textit{tail} are used to keep track of the queue during operation. Listing \ref{javaqueue} shows an extract of some of these important fields.

\lstinputlisting[label=javaqueue,caption=Queue fields and the Element type]{Code/Implementation/javaqueue.java}

Upon queue initialisation, empty elements are instantiated and chained together until the queue reaches the maximum size, \code{capacity}. Methods for dequeue, enqueue and reset are available. Listing \ref{javaqueuedequeue} shows the dequeue implementation.

\lstinputlisting[label=javaqueuedequeue,caption=The dequeue method.]{Code/Implementation/javaqueuedequeue.java}

In the loop of the above method, a privately defined \code{dequeue} method is invoked (infinitely or until timeout), which tries to remove the \textit{head} of the queue if present (null is returned otherwise). Figure \ref{img:queue.pdf} graphically illustrates the queue implementation.

\img{queue.pdf}{0.6}{The generic queue implementation for a queue with a capacity of 5}

The queue will work within a SCJ environment as all methods are measurable in terms of WCET. The loop of the \code{enqueue} method is bounded on waiting time, however, this time is known in advance as it is determined by the library user and can thus be included in the WCET calculations.