\subsection{Queue Data Structure} % (fold)
\label{sub:queue}
At several places in the C implementation that are in correlation with initialisation, \textit{queue} data structures, supporting easy and thread-safe access through mutual exclusion, are allocated. Despite being used for holding common elements such as connections and packets, they possess yet another important role - information exchange and enablement of communication between threads. As an example, a user-defined thread hosting a server application can invokes the \code{csp\_accept} function, which waits (infinitely or for some specified period of time) for a new incoming connection by trying to dequeue its empty local connection queue. When a new client wants to establish a connection to the server and sends the first packet through the network, the packet is received and forwarded to the routing tasks packet queue. During packet processing, a new connection element is established in which the packet is enqueued. The connection is then enqueued in the servers connection queue, which wakes up the server thread to fulfil the dequeue operation. Listing \ref{cqueue}, shows how threads communicates through queue operations by waiting and waking each other up based on queue conditions.

\lstinputlisting[label=cqueue,caption=Simplified enqueue and dequeue operations in the C implementation of CSP.]{Code/Implementation/cqueue.c}

To model a similar behaviour in SCJ for dealing with sockets, connections and packets some of the same mechanisms can be utilised - i.e having queues in conjunction with handler communication. Unfortunately invocations of \code{Object.wait}, \code{Object.notify} and \code{Object.notifyAll}, are disallow in compliance level 1, so other means of enabling communication is required. To circumvent this lack of SCJ language constructs, we will create a queue, which can be polled until a successful dequeue operation occurs or until some timeout (possibly none) takes place. The queue could be implemented as a simple \code{ArrayList}, however, only arrays are available in the compliant Java version (1.1). As a consequence of this limitation, we will create a \code{Queue} class with our own underlying data structure for storage. As the queue needs to be able to cope with different elements of different types (\code{Socket}, \code{Connection} and \code{Packet}), it is created as a generic class. Again due to language version limitations, we need to create an inner class, \code{Element}, that contains an element and a reference to the next element as we are prohibited from creating generic arrays. In other words, it works as a circular buffer. In addition references to the \textit{start}, \textit{head} and \textit{tail} of is needed to keep track of the queue during operation. Listing \ref{javaqueue} shows an extract of some of these important fields.

\lstinputlisting[label=javaqueue,caption=Queue fields and the \textit{Element} type]{Code/Implementation/javaqueue.java}

Upon queue initialisation, empty elements are instantiated and chained together until the queue reaches the maximum size, \code{capacity}. Methods to dequeuing, enqueue and erase all content are available. Listing \ref{javaqueuedequeue} shows the dequeue implementation.

\lstinputlisting[label=javaqueuedequeue,caption=The dequeue method.]{Code/Implementation/javaqueuedequeue.java}

In the loop of the above method, a privately defined \code{dequeue} method is invoked (infinitely or until timeout), which tries to remove the \textit{head} of the queue if present (null is returned otherwise).

The queue will work within a SCJ environment as all methods are measurable in terms of WCET. The loop of the \code{enqueue} method is bounded on waiting time, however, this time is known in advance as it is determined by the library user and can thus be included in the WCET calculations.