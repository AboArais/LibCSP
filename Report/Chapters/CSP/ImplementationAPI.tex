\subsection{Transparent Scoped Memory Handling} % (fold)
\label{sub:transparent_memory_}
The use of the resource pools are made transparent by the \code{CSPManager} through which client applications use the implementation. Retrieving a \code{Socket}, \code{Connection} or \code{Packet} is done as seen in Listing \ref{createsocket} for \code{Socket}.
\lstinputlisting[label=createsocket,caption=The createSocket method of CSPManager]
{Code/Implementation/createsocket.java}

Ensuring that a \code{Socket} and \code{Connection} object is put back into the queue is done by implementing this in the \code{close} method on \code{SocketCore} and \code{ConnectionCore}. \code{Packet}, however, does not have a \code{close} method available, thus packets that are not sent, but read through a connection must manually be put back into the pool. Instead we take advantage of the scoped memory model in the \code{read} method on \code{ConnectionCore}. Rather than returning the actual \code{PacketCore} object that resides in mission memory, we instantiate a new object during the read, returns this newly allocated \code{PacketCore} object and puts the existing back into the pool. This is seen in Listing \ref{readpacket}. The new packet object is allocated in a private memory area, in the context of the executing handler, and will be deallocated later according to the memory semantics. We will denote this technique as \textit{Transparent Use of Resource Pool}.
\lstinputlisting[label=readpacket,caption=The read method on ConnectionCore]
{Code/Implementation/packetread.java}


We emphasize that the scoped memory model presents additional possibilities. To ensure that, in this case of using resource pools, that objects are always returned, one could use a technique similar to one often used in C++ --- \textit{Resource Acquisition Is Initialization}~(RAII)\cite{RAII}. While the use of locks is exception-safe in Java, this technique provides other uses. Returning an object to the pool could happen in the \code{finalize()} method of an encapsulating object and thereby always be executed. However, as \code{finalize()} is currently not implemented in the Java version on JOP, this technique has not been applied. Additionally the semantics of this would have to be changed to the memory model.