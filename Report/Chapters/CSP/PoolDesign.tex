\subsection{Resource Buffers}
The scoped memory model in SCJ requires some additional work underneath in the implementation. In several parts, a problem similar to the producer-consumer problem arise. The following are two examples of issues that arise as a result of the memory model:
\begin{itemize}
	\item A handler may be awaiting packets on a connection, which will be produced by incoming data and delivered by the routing handler. Packets that arrive are extracted in the aperiodic event handler implementing the MAC-layer protocol for some hardware interface. This packet must subsequently be transferred to a memory area available for the awaiting handler.
	\item A socket may be initialized and placed in mission memory in an application. Whenever a connection is made upon receiving data this must therefore also be placed in mission memory. The reason for this, is that connections are associated with sockets, but the particular socket object cannot have a reference to a connection if this is allocated in a private memory area.
\end{itemize}

As a result we use a \textit{Resource Pool}\cite{Rios:2012:PSJ:2388936.2388938} in which a static amount of \code{Socket}, \code{Connection} and \code{Packet} objects are allocated during the applications initialization phase and will thus exist in the same memory area. During execution phase, no additional objects of these types are allocated. The class \code{ResourcePool} will store all unused objects and provide an interface for retrieving and object and putting one back into the pool. The advantage of this approach is that it ensures that no run-time exceptions occur as a result of having references to shorter lived objects. A disadvantage of this approach is that there will an overhead in copying values to the fields of objects that are retrieved from the pool. 