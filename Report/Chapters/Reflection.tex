\chapter{Reflection and Findings}
\label{chapter:Reflection}
In this chapter we look at the results of having worked with Safety-Critical Java. It is both the considerations in relation to the subsidiary questions of the problem statement, as well as additional findings that may form the basis for future work.

\section{Programming Model} 
\label{sec:programming_model}
In general we easily adapted to the programming model in SCJ under compliance level~1 and found the event-based concurrency model intuitive to work with. Despite working with event handlers as first-class objects rather than threads as in standard Java, prior experience in concurrency is easily converted to the model in SCJ. Furthermore the explicit requirement of having to implement the logic for the release of a task in the \code{handleAsyncEvent} method, can easily be compared to that of implementing the \code{run} method in standard Java. Intuitively, this approach also transfers well to the domain itself, with event handlers being fired by the underlying infrastructure by time or triggered events. The programming model therefore supports the ability to let experienced Java developers leverage their prior knowledge in the area of developing safety-critical systems in terms of the concurrency model.

A troublesome part of the model is the requirement of explicitly stating storage parameters by the application developer. This can quickly become a complex task as both memory sizes of the immortal, mission and private memory areas must be defined, as well as stack sizes for the handlers. Furthermore, this is not done separately as the storage parameters include both the scope size itself as well as the total backing store that includes any enclosed scope. The majority of the time during the development we found that this was mostly done in a trial-and-error based approach, often by setting the values as high as possible. Setting these storage parameters correctly requires knowledge of both allocations in all scopes, but also on the underlying platform such as the size for each type. This requirement of needing deep knowledge on the underlying platform in order to correctly assign these storage parameters, goes against the idea of Java which aims for a higher level of abstraction. On the other hand, developing safety-critical systems will always require solid knowledge on the applied platform, however, we believe this is one of the more complex tasks future SCJ developers will encounter.

\section{Scoped Memory Model} % (fold)
 \label{sec:scoped_memory_model}
In our experience, the memory model arguably poses some of the most significant challenges developers must adapt to. The difference between immortal and mission memory and their purpose is clear, however, it is unclear when the transition between the allocation context of each directly occurs. Because there is no explicit method in which allocations are done in immortal memory, we found it unclear in which area anything before the \code{initialize} method on a mission was allocated. This may for example result in objects being allocated in immortal memory that were intended for mission memory. As a consequence of this misplacement, allocating new objects in mission memory and assigning these to fields in an object which is thought living in the same scope, run-time exceptions are thrown, which may be troublesome to debug. In order for correctly determining this switch in allocation context, the implementation of the memory model and \textit{initialization} phase of SCJ on JOP had to be examined in details. We would therefore like to see a more explicit change in allocation context between immortal and scoped memory, e.g. with a similar explicit initialise method for the immortal memory area. Similar reflections were also found in the RepRap use case\cite{Schoeberl:2012:RepRap} as they encountered the same issue.

During our work, we encountered the producer-consumer problem which was a challenge to handle in the scoped memory model. What we found was that the use of the resource pool pattern was considered a generally applied method, with the drawback of copying primitive types when transferring values between memory areas. With the use of resource pools (and the scoped model in general) there is the risk of memory leaks. If a reference to an object in mission memory is lost, this object is useless and will not be deallocated until the end of a mission --- and similarly with immortal memory, not until the whole application terminates. Considering the explicit storage parameters, and that no further objects are allocated in these scopes during \textit{execution} phase, this is not as problematic as memory leaks in general. However, in the case of using resource pools this would result in, at some point, no further objects ever being available if objects are not returned to the pool. Therefore this technique requires extra care when applied. We attempted to handle this by not placing such responsibility on the application developer, but do this as a part of the general API (e.g. putting a socket back to the pool when closing). This approach of covering the use of a resource pool was not applicable for packets, in which we made the \textit{Transparent Use of Resource Pool} technique. We attempted to apply the \textit{RAII} technique from C++, but this is currently not possible. We believe that this technique could be suitable in SCJ, when using resource pools. Moreover, considering that multiple handlers often communicates, we estimate that this may often be needed.

In general, we find that the memory model presented the biggest challenges and requires the most change in mindset. Having no garbage collection was for us the biggest challenge encountered. Furthermore as the current standard Java libraries that are available on CSP for JOP are directly taken in their original form, many of these must also be used with extra care. We consider any attempts at simplifying the memory model and its use valuable.

 \section{Restrictions on Synchronisation} % (fold)
 \label{sec:restrictions_on_synchronisation}
The restrictions in use of synchronisation also presented challenges. For the queue data structure, one of the challenges was the prohibition of \code{Object\-.wait} and \code{Object\-.notify} in compliance level~1. This restriction of language expressiveness complicates certain implementations including our own and in order to bypass it in the queue, we resolved to a busy waiting strategy. The need for this approach has also complicated analysis of execution time for the implementation as it is now bound by time, as well as the risk of being blocked when it attempts to perform a dequeue. As a result, determining WCET of a part in an application that specifies a timeout rather than performing a single attempt dequeue cannot be measured using static analysis. End-to-end measurement will be needed in this case.

The restriction on not being able to use synchronised blocks resulted in moving pieces of code that should be executed under mutual exclusion into synchronised methods. While this was not considered a major issue (and in fact sometimes led to better code), the motivations behind this restriction is not clear. The restriction itself did not present any difficulties.