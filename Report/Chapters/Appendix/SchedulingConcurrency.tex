\chapter{Scheduling and Concurrency in SCJ}
\label{chapter:scheduling}
Traditionally, safety-critical systems have been small programs that were constructed using the cyclic executive scheduling approach. However, a gradual shift towards the use of concurrency has lead to more complex safety-critical systems. This has resulted in programming models where simple concurrent activites have become viable in the development of safety-critical systems. As a result, there has been a migration from \textit{deterministic} scheduling to \textit{predictable scheduling}, where verification is done through schedulability analysis such as the response time analysis, described in Section \ref{sec:schedulability_analysis}. This verification is then typically appended as evidence in the certification process. In Section \ref{subsection:handlers} an example of a Mars rover illustrated how to create the fundamental event handlers. In this Section we examine the underlying motivations for this approach towards constructing safety-critical applications and details on the infrastructure.

% SCJ supports both the creation of applications relying on a cyclic executive as well as more complex concurrent ones. As described in Section \ref{section:complianceLevels} a total of three compliance levels exists. These compliance levels indicates the complexity of the safety-critical application, where the concurrency and scheduling becomes more comprehensive and complex at higher levels. In the following we examine the general concurrency model, followed by more extensive details on the differences at each level as well as details on the concurrency and scheduling infrastructure.

% Traditionelt anvendt cyclic executive. Der er sket en gradvis migrering til at anvende prorgamming models der understøtter concurrenct activities.  Skift fra deterministic scheduling til predictable scheduling. Verification sker ved schedulability analyse såsom RTA i section x, som typisk vil være bevis til certificerings processen.

\section{Concurrency Model} % (fold)
\label{sub:concurrency_model}
In general, the two concurrency models, \textit{thread-based} and \textit{event-based} exists. In the thread-based model a single thread of control is used for each entity. In the event-based model, an event handler begins executing in response to an event being fired. In SCJ, the concurrency model is based on an event-based approach (almost) exclusively. This is in contrast to RTSJ which incorporates both models. Let us consider some of the motives behind this restriction. 

First, In RTSJ one can implement both heap and no-heap (i.e. never allocates any objects) real time threads, as well as heap and no-heap event handlers with little restrictions. As a consequence, it can be more difficult to construct the application and awkward cases in which a single release is associated with mixed responsibilies that ideally should be placed in different releases is permitted. As a result, the application becomes more complex to analyse and thereby verify its schedulability. Consider the example of a periodic task implemented in RTSJ, listed in Listing \ref{periodicrtsjtask}\footnote{The example is adapted from a RTSJ application found in the article, \textit{Garbage collection for safety critical java}\cite{Schoeberl:2007:GCS:1288940.1288953}}. Not only does this implementation contain two different units of work to be performed on a release (\code{doModeAWork} and \code{doModeBWork}) depending on a manually maintained state. Analysis also becomes more complex by the unbounded loop and the \code{waitForNextPeriod} method that blocks the thread until its next release.

\lstinputlisting[label=periodicrtsjtask,caption=An example of a periodic Task in RTSJ]
{Code/Concurrency/concurrency_periodic_rtscj.java}

In SCJ all tasks are implemented as event handlers and a unit of work to be executed on each release is implemented in the \code{handleAsyncEvent} method that was illustrated in the application example in Section \ref{subsection:handlers}. This method is invoked by the underlying infrastructure making it more easy to perform analysis as well as support static analysis tools.

A second motivation for an event-based model, is that of binding threads. In RTSJ an asynchronous event handler always executes under the control of a thread, however, when this binding occurs is not specified. This can either happen just before the release (allowing reuse of threads for different handlers) in which the event handlers are \textit{unbound}. Otherwise , the asynchronous event handler may also be \textit{bound} permanently to a thread upon creation. The important part of this, is that asynchronous event handlers are effectively real-time threads and is no different in terms of scheduling. There is therefore no significant drawback in using asynchronous event handlers. This supports the first motivation for using the event-based model. In addition, only bound asynchronous event handlers are allowed, as this is more predictable considering no latency occurs due to the need for binding upon release.

\section{Cross-Level Semantics and Restrictions} % (fold)
\label{sub:cross_level_restrictions}
% subsection cross_level_restrictions (end)
%As described previously, SCJ supports bound asynchronous event handlers almost exclusively (level 2 applications may use a simplified thread-based approach as will be described). Despite cyclic executive being implemented as event handlers, these are not executed concurrently. These will always be executed sequentially in a single thread.
%In SCJ, code that will be executed by a preemptive scheduler, is coined the \textit{schedulable object} as previously described. The event handlers implemented in a non-cyclic executive are then released and executed in response to release events that can be either time-triggered or event-triggered. 
As described in Section \ref{sub:real_time_tasks}, tasks are usually distinguished between being either periodic, aperiodic or sporadic. While RTSJ supports all three task types, SCJ is restricted to periodic and aperiodic tasks. Therefore no enforcement of minimum inter-arrival times between release events is present, and relies on the application developer. It is not evident why sporadic handlers are not supported, however, overhead in run-time timing checks may be an obvious reason. Similarly issues with \textit{jitter} may further the complexity of this task, thus result in less predictability. As a result, one must model sporadic tasks as aperiodic event handlers instead.

In addition to this, there are a number of restrictions that application developers must conform to regardless of compliance level\footnote{We here provide semantics for single-processor based platforms. For additional details on multi-processor uses, we refer to the specification.}:
\begin{itemize}
	\item The \textit{synchronise} statement is not allowed. Synchronisation is done using synchronised methods or the use of the volatile modifier for primitive types.
	\item Nested calls of synchronised methods are allowed.
	\item No synchronised code may self-suspend while holding a monitor lock (e.g. for I/O or the use of the \code{sleep} method). Note that requesting a lock through a synchronised call is not considered self-suspension in this case.
\end{itemize}

It is not clear what motives are behind not allowing the use of the synchronised statement, as equivalent code can easily be produced by encapsulation in a synchronised method.
In addition to these there are also specific semantics and restrictions depending on the compliance level. These will be described in the following.
% subsection concurrency_model (end)

% Concurrency Model
% - event / thread based, event baseret med bound threads/schedulable objects
% - Generelle betingelser på tværs af compliance levels

\section{Level Specific Semantics and Restrictions} % (fold)
\label{sub:level_specific_restrictions}
In addition to the semantics that apply across levels the following apply to the individual levels. These also show how the complexity of applications increase as a result of conforming to a higher compliance level.

\subsection{Level 0}
\begin{itemize}
	\item Only periodic bound asynchronous event handlers supported (though executed as if it was under a single thread of control).
	\item The use of the suspending method \code{Object.wait} and appertaining methods \code{Object.notify} and \code{Object.notifyAll} are not allowed.
	\item No deadline miss detection facilitated.
\end{itemize}

\subsection{Level 1}
The following apply in addition to the level 0 requirements.
\begin{itemize}
	\item Aperiodic and one-shot asynchronous event handlers are allowed.
	\item Each event handler is bound to its own thread of control, and similarly, each thread only serves a single handler.
	\item Deadline miss detection is facilitated under a certain granularity.
	\item A preempted schedulable object must be placed in front of the queue for its active priority (This is only a recommendation in RTSJ).
\end{itemize}

\subsubsection{Level 2}
The following apply in addition to the level 1 requirements.
\begin{itemize}
	\item No-heap real-time threads are supported (but these are still managed).
	\item \code{Object.wait}, \code{Object.notify} and \code{Object.notifyAll} are allowed.
\end{itemize}

As it can be seen, language constructs and methods that makes analysis complex and programs less predictable are not allowed in level 0 and 1 applications. Level 2 application lifts many restrictions, and it can be questioned whether actual safety-critical applications will be developed to conform to this level. We estimate that the majority of safety-critical applications will be targeted level 0 and 1. This was hinted when covering the different compliance levels in Section \ref{section:complianceLevels}.

With the fundamental model on concurrency in SCJ outlined, we now turn to the more detailed areas of scheduling and threading, as specified in the specification.

% subsection scheduling_ (end)
\section{Scheduling and Priority Inversion Avoidance} % (fold)
\label{sub:schedulingobjects}
As stated, the scheduling of schedulable objects in SCJ is done explicitly by a full preemptive fixed-priority scheduler for level 1 and 2 applications. In addition the scheduler must at least be able to handle 28 different priorities (otherwise depends on the implementation). This is equivalent to the scheduling specified in RTSJ. Because of support for communication between schedulable objects in SCJ, a priority inversion management protocol is necessary. SCJ explicitly uses \textit{Priority Ceiling Emulation} (otherwise known as \textit{Immediate Ceiling Priority Protocol}, ICPP). This is different from RTSJ in which inheritance is the standard protocol, and the ceiling protocol may be used optionally. As a result, whenever a task locks a resource (such as when successfully invoking a synchronised method), its priority is raised to the ceiling of that particular resource. The ceiling priority of each resource is defined as the maximum of all tasks that uses it. For additional information on different priority avoidance protocols and their differences we refer to \cite{alan2001real}.

For controlling the scheduling of schedulable objects, a number of classes are used by the scheduler. Furthermore objects of these classes are used to parametrise the event handlers. These objects have been inherited from RTSJ except for parameter classes related to memory usage. As illustrated in the simple example of an SCJ application in \ref{subsection:handlers}, these parameter objects allows one to specify the timing constraints of the event handlers (in fact, the notion real-time threads in RTSJ is the specification of an original \code{java.lang.Thread} together with such scheduling parameters). Figure \ref{img:parameters_uml.pdf} illustrates all of the parameter classes that are used to control the scheduling of schedulable objects and memory usage.

\img{parameters_uml.pdf}{0.6}{The parameters class hierarchy used by the infrastructure.}

It is clear that many of the restrictions are defined in order to simplify the whole infrastructure and make it more predictable. For instance, it is known that the Priority Ceiling Emulation has the benefit of being more easy to implement, but also leads to fewer context switches and ensures the absence of deadlocks\cite{alan2001real}. However, this also comes at the cost of not being allowed to invoke self-suspending calls in handlers such as \code{Object.wait} (except in level 2, however, additional restrictions apply in this case). The consequences of this, is that for many data structures such as a queue, in which a Java programmer would normally use \code{Object.wait}, one must think differently.

% subsection scheduling_and_asynchronous_event_handlers (end)